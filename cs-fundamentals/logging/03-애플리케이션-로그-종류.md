# 애플리케이션 로그의 종류

---

## 1. 왜 로그를 분류하는가?

모든 로그를 한 곳에 뒤섞어 놓으면:

```
  ├── 개발자가 에러를 찾으려는데 사용자 행동 로그 수만 줄이 끼어있음
  ├── 보안팀이 침입 흔적을 찾으려는데 성능 로그가 대부분
  ├── 감사팀이 데이터 변경 이력을 보려는데 디버그 로그에 묻힘
  └── 결국 "건초더미에서 바늘 찾기"
```

**로그를 목적별로 분류**하면:
- 필요한 로그만 빠르게 검색 가능
- 역할별로 접근 권한 분리 (보안팀만 감사 로그 접근)
- 보존 정책 차별 적용 (감사 로그 7년, 디버그 로그 7일)
- 저장소·비용 최적화

---

## 2. 전체 분류 체계

```
                          애플리케이션 로그
                               │
         ┌─────────────────────┼─────────────────────┐
         │                     │                     │
    운영 로그              보안 로그             비즈니스 로그
  (Operational)          (Security)           (Business)
         │                     │                     │
  ┌──────┼──────┐       ┌──────┼──────┐       ┌──────┼──────┐
  │      │      │       │      │      │       │      │      │
요청   에러   성능     인증   접근   감사     트랜잭션 행동   변경
/접근  로그   /가용성  로그   제어   로그      로그   로그   로그
로그         로그           로그
```

> 📌 이 분류는 절대적 기준이 아니다. 조직마다, 도메인마다 분류가 다를 수 있다.
> 핵심은 **"누가, 왜 이 로그를 보는가"** 에 따라 나누는 것이다.

---

## 3. 운영 로그 (Operational Logs)

> **목적: "시스템이 잘 돌아가고 있는가?"**

### 3.1 요청/접근 로그 (Access Logs / Request Logs)

**정의**: 시스템으로 들어오는 **모든 요청과 응답**을 기록

이것은 웹 서버/API 서버 로그의 가장 근본이 되는 형태이다.

#### 역사: Apache 로그 포맷의 탄생

웹 초기부터 요청 로그의 표준 포맷이 존재했다:

**Common Log Format (CLF) — 최초의 표준:**

```
203.0.113.42 - frank [24/Feb/2026:18:30:00 +0900] "GET /index.html HTTP/1.1" 200 1234
```

| 필드 | 값 | 설명 |
|------|------|------|
| 클라이언트 IP | `203.0.113.42` | 요청을 보낸 곳 |
| ident | `-` | RFC 1413 신원 확인 (거의 사용 안 함) |
| 사용자명 | `frank` | HTTP 인증 사용자 (없으면 `-`) |
| 타임스탬프 | `[24/Feb/2026:18:30:00 +0900]` | 요청 시각 |
| 요청 라인 | `"GET /index.html HTTP/1.1"` | 메서드 + 경로 + 프로토콜 |
| 상태 코드 | `200` | HTTP 응답 코드 |
| 응답 크기 | `1234` | 응답 바이트 수 (헤더 제외) |

**Combined Log Format — CLF 확장:**

```
203.0.113.42 - frank [24/Feb/2026:18:30:00 +0900] "GET /index.html HTTP/1.1" 200 1234 "https://google.com" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
```

CLF에 두 필드가 추가:

| 추가 필드 | 설명 | 왜 중요? |
|----------|------|---------|
| Referer | 어디서 왔는가 | 트래픽 출처 분석, 핫링크 탐지 |
| User-Agent | 어떤 브라우저/봇인가 | 봇 탐지, 브라우저 호환성 |

> 📌 Apache, Nginx 모두 이 Combined Log Format을 기본으로 사용한다.

#### 현대적 요청 로그 (JSON 구조화)

현대 API 서버에서는 훨씬 풍부한 정보를 구조화하여 기록한다:

```json
{
  "timestamp": "2026-02-24T18:30:00.123+09:00",
  "type": "request",
  "request": {
    "method": "POST",
    "path": "/api/v2/orders",
    "query": "?currency=KRW",
    "headers": {
      "content_type": "application/json",
      "user_agent": "MyApp/2.3.1 (iOS 19.0)",
      "x_request_id": "req-abc-123"
    },
    "body_size_bytes": 256,
    "client_ip": "203.0.113.42"
  },
  "response": {
    "status_code": 201,
    "body_size_bytes": 128,
    "headers": {
      "x_request_id": "req-abc-123"
    }
  },
  "latency_ms": 245,
  "user_id": "U-456",
  "trace_id": "trace-xyz-789"
}
```

**요청 로그에서 파악할 수 있는 것:**
- 🔍 어떤 API가 가장 많이 호출되는가? (트래픽 패턴)
- 🐌 어떤 엔드포인트가 느린가? (성능 병목)
- ❌ 4xx/5xx 에러가 집중되는 곳은? (장애 지점)
- 🤖 비정상적 패턴은? (봇 공격, DDoS)

---

### 3.2 에러 로그 (Error Logs)

**정의**: 예기치 않은 오류, 예외(Exception), 시스템 장애를 기록

```json
{
  "timestamp": "2026-02-24T18:30:00.123Z",
  "level": "ERROR",
  "service": "order-service",
  "instance": "order-pod-3",
  "message": "Failed to process order",
  "error": {
    "type": "ConnectionTimeoutError",
    "message": "Connection to payment-gateway timed out after 30s",
    "stack_trace": [
      "at PaymentClient.charge(PaymentClient.java:142)",
      "at OrderService.processPayment(OrderService.java:89)",
      "at OrderController.createOrder(OrderController.java:34)"
    ]
  },
  "context": {
    "order_id": "ORD-2026-001",
    "customer_id": "CUST-789",
    "amount": 125000,
    "currency": "KRW",
    "retry_attempt": 3,
    "max_retries": 3
  },
  "trace_id": "abc-123-def",
  "span_id": "span-456"
}
```

#### 좋은 에러 로그의 조건

```
에러 로그는 이 질문들에 답할 수 있어야 한다:

  1. 뭐가 실패했나?    → error.type, error.message
  2. 왜 실패했나?      → error.stack_trace, root cause
  3. 어디서 실패했나?   → service, instance, 코드 위치
  4. 뭘 처리하다 실패?  → context (주문번호, 고객ID 등)
  5. 언제?            → timestamp
  6. 영향 범위는?      → 이 에러가 전체 시스템인지, 특정 요청인지
  7. 재현 가능한가?     → 요청 파라미터, 입력값
```

#### 에러 vs 예외: 모든 예외가 에러 로그는 아니다

```
예외 (Exception)                    에러 로그에 남겨야 하나?
─────────────────────────────────   ─────────────────────────
UserNotFoundException               ❌ 예상된 상황 (404 반환)
  → "없는 사용자를 조회" 

InvalidInputException               ❌ 클라이언트 잘못 (400 반환)
  → "잘못된 이메일 형식"

DatabaseConnectionException         ✅ 시스템 문제 (500 반환)
  → "DB에 연결할 수 없음"

OutOfMemoryError                    ✅ 심각한 시스템 문제 (FATAL)
  → "메모리 부족"

PaymentGatewayTimeout               ✅ 외부 의존성 실패 (503 반환)
  → "결제 게이트웨이 무응답"

RateLimitExceededException          🟡 상황에 따라 (WARN)
  → "API 호출 한도 초과"
```

---

### 3.3 성능 / 가용성 로그 (Performance & Availability Logs)

**정의**: 응답 시간, 리소스 사용량, 시스템 상태를 기록

#### 성능 로그

```json
{
  "timestamp": "2026-02-24T18:30:01.456Z",
  "type": "performance",
  "endpoint": "GET /api/users/{id}",
  "metrics": {
    "response_time_ms": 245,
    "breakdown": {
      "middleware_ms": 3,
      "auth_ms": 12,
      "db_query_ms": 180,
      "serialization_ms": 12,
      "network_ms": 38
    }
  },
  "percentiles": {
    "p50_ms": 120,
    "p95_ms": 450,
    "p99_ms": 1200
  }
}
```

> 📌 **왜 p50이 아니라 p95, p99를 봐야 하나?**
> 
> 평균 응답 시간이 100ms라도, 100명 중 1명은 5초를 기다릴 수 있다.
> p99 = "100번 요청 중 99번째로 느린 시간" → 최악의 사용자 경험을 나타낸다.

#### 가용성 로그 (헬스 체크)

```json
{
  "timestamp": "2026-02-24T18:30:02.789Z",
  "type": "health_check",
  "service": "user-service",
  "overall_status": "degraded",
  "checks": {
    "database": {
      "status": "healthy",
      "latency_ms": 5,
      "connection_pool": { "active": 8, "idle": 42, "max": 50 }
    },
    "redis_cache": {
      "status": "unhealthy",
      "error": "Connection refused",
      "last_successful": "2026-02-24T18:25:00Z"
    },
    "disk": {
      "status": "warning",
      "usage_percent": 87,
      "free_gb": 13
    }
  },
  "uptime_seconds": 864000,
  "version": "2.3.1"
}
```

**가용성 상태 분류:**

```
  healthy   → 모든 의존성 정상
  degraded  → 일부 기능 제한 (캐시 불가 등)
  unhealthy → 핵심 기능 불가 (DB 다운 등)
```

---

## 4. 보안 로그 (Security Logs)

> **목적: "누가 시스템에 접근하고, 무엇을 했는가?"**

### 4.1 인증 로그 (Authentication Logs)

**정의**: **"당신이 누구인지"** 를 확인하는 과정의 모든 시도와 결과를 기록

```json
{
  "timestamp": "2026-02-24T18:31:00.000Z",
  "level": "WARN",
  "type": "authentication",
  "event": "login_failed",
  "subject": {
    "identifier": "user@example.com",
    "ip_address": "203.0.113.42",
    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
    "geo": { "country": "KR", "city": "Seoul", "asn": "AS4766" }
  },
  "details": {
    "method": "password",
    "failure_reason": "invalid_password",
    "consecutive_failures": 4,
    "lockout_threshold": 5,
    "account_locked": false,
    "mfa_status": "not_attempted"
  },
  "risk_indicators": {
    "new_device": true,
    "unusual_location": false,
    "tor_exit_node": false,
    "known_bad_ip": false
  }
}
```

**반드시 기록해야 할 인증 이벤트 전체 목록:**

| 이벤트 | 왜 기록하나? | 위험 시나리오 |
|--------|-----------|-------------|
| 로그인 성공 | 정상 접근의 기준선 확보 | 탈취된 계정으로 정상 로그인 |
| 로그인 실패 | 무차별 대입 공격 탐지 | 1분에 100번 실패 = 공격 |
| 로그아웃 | 세션 생명주기 추적 | 로그아웃 없이 세션 유지 = 탈취 가능성 |
| 비밀번호 변경 | 계정 장악 시도 탐지 | 공격자가 비밀번호 변경 후 원래 주인 차단 |
| 비밀번호 재설정 | 소셜 엔지니어링 탐지 | 가짜 재설정 요청 |
| MFA 등록/해제 | 보안 수준 변경 추적 | 공격자가 MFA 해제하여 보안 약화 |
| MFA 인증 시도 | 2차 인증 우회 시도 탐지 | OTP 무차별 대입 |
| 세션 생성/만료 | 동시 세션 모니터링 | 동일 계정 다국적 접속 = 탈취 |
| API 키/토큰 발급 | 프로그래밍 접근 추적 | 유출된 API 키로 자동화 공격 |
| 계정 잠금/해제 | 공격 대응 추적 | 잠긴 계정 관리자 해제 = 내부자 위협 |

---

### 4.2 접근 제어 로그 (Authorization / Access Control Logs)

**정의**: **"당신이 이것을 할 권한이 있는지"** 확인한 결과를 기록

> 📌 **인증(Authentication) vs 인가(Authorization)**
> - 인증 = "너 누구야?" (신원 확인)
> - 인가 = "너 이거 해도 돼?" (권한 확인)

```json
{
  "timestamp": "2026-02-24T18:32:00.000Z",
  "level": "WARN",
  "type": "authorization",
  "event": "access_denied",
  "subject": {
    "user_id": "U-456",
    "role": "viewer",
    "groups": ["team-alpha"],
    "session_id": "sess-abc123"
  },
  "action": {
    "type": "delete",
    "verb": "DELETE",
    "endpoint": "/api/v2/documents/DOC-789"
  },
  "resource": {
    "type": "document",
    "id": "DOC-789",
    "owner": "U-123",
    "classification": "confidential"
  },
  "decision": {
    "result": "denied",
    "policy": "rbac_document_policy",
    "reason": "Role 'viewer' lacks permission 'document:delete'",
    "required_permissions": ["document:delete"],
    "granted_permissions": ["document:read"]
  }
}
```

**접근 제어 로그에서 탐지할 수 있는 위협:**

```
패턴 1: 수평적 권한 상승 (Horizontal Privilege Escalation)
  └─ 사용자 A가 사용자 B의 데이터에 접근 시도
  └─ 예: GET /api/users/B-123/profile (자기 계정이 아닌데 접근)

패턴 2: 수직적 권한 상승 (Vertical Privilege Escalation)
  └─ 일반 사용자가 관리자 기능에 접근 시도
  └─ 예: DELETE /api/admin/users/U-789 (admin이 아닌데 호출)

패턴 3: 열거 공격 (Enumeration Attack)
  └─ 순차적으로 리소스 ID를 바꿔가며 접근 시도
  └─ 예: GET /api/documents/1, /api/documents/2, /api/documents/3...

패턴 4: 접근 거부 폭증 (Access Denied Spike)
  └─ 특정 IP/사용자에서 접근 거부가 급증
  └─ 정상 사용자는 접근 거부가 거의 없어야 함
```

---

### 4.3 감사 로그 (Audit Logs)

**정의**: **"누가, 언제, 무엇을, 어떻게 변경했는지"** 를 변조 불가능하게 기록

감사 로그는 보안 로그의 가장 상위 개념이며, 법적 증거로도 사용될 수 있다.

```json
{
  "timestamp": "2026-02-24T18:33:00.000Z",
  "level": "INFO",
  "type": "audit",
  "event_id": "AUD-2026-00456",
  "event": "data_modified",
  "actor": {
    "user_id": "ADMIN-001",
    "role": "system_admin",
    "ip_address": "10.0.1.50",
    "session_id": "sess-abc123",
    "auth_method": "sso_mfa"
  },
  "action": "UPDATE",
  "target": {
    "entity_type": "user_account",
    "entity_id": "U-789",
    "changes": [
      {
        "field": "role",
        "before": "viewer",
        "after": "editor",
        "reason": "승진에 따른 권한 변경"
      },
      {
        "field": "department",
        "before": "개발팀",
        "after": "보안팀",
        "reason": "부서 이동"
      }
    ]
  },
  "approval": {
    "change_request_id": "CR-2026-042",
    "approved_by": "ADMIN-002",
    "approved_at": "2026-02-24T18:00:00Z"
  },
  "integrity": {
    "hash": "sha256:a1b2c3d4e5f6...",
    "previous_hash": "sha256:f6e5d4c3b2a1...",
    "sequence_number": 456
  }
}
```

#### 감사 로그의 4대 원칙

```
┌───────────────────────────────────────────────────────────┐
│                    감사 로그 4대 원칙                        │
│                                                            │
│  ① 불변성 (Immutability)                                   │
│     └─ 한번 기록된 로그는 절대 수정·삭제 불가                   │
│     └─ Append-only 저장소 사용                              │
│     └─ 기술: WORM 스토리지, 불변 DB (immudb)                 │
│                                                            │
│  ② 무결성 (Integrity)                                      │
│     └─ 로그가 변조되지 않았음을 검증 가능                       │
│     └─ 각 레코드의 해시(hash)를 체이닝                        │
│     └─ 기술: 해시 체인, Merkle 트리, 디지털 서명               │
│                                                            │
│  ③ 완전성 (Completeness)                                   │
│     └─ 변경 전(before)과 후(after) 상태를 모두 기록             │
│     └─ 누락된 이벤트가 없어야 함                              │
│     └─ 기술: 시퀀스 번호로 갭 탐지                            │
│                                                            │
│  ④ 비부인 (Non-repudiation)                                │
│     └─ 행위자가 자신의 행위를 부인할 수 없게 보장               │
│     └─ 기술: 디지털 서명, MFA 인증 후 행위 기록                │
└───────────────────────────────────────────────────────────┘
```

#### 해시 체인으로 변조 탐지

```
  Record #1                Record #2                Record #3
  ┌──────────┐            ┌──────────┐            ┌──────────┐
  │ data: ... │            │ data: ... │            │ data: ... │
  │ hash: H1  │───prev───▶│ prev: H1  │───prev───▶│ prev: H2  │
  │ prev: ∅   │            │ hash: H2  │            │ hash: H3  │
  └──────────┘            └──────────┘            └──────────┘
  
  H1 = SHA256(Record#1의 데이터)
  H2 = SHA256(Record#2의 데이터 + H1)    ← H1이 포함됨!
  H3 = SHA256(Record#3의 데이터 + H2)    ← H2가 포함됨!

  만약 누군가 Record#2를 몰래 수정하면?
  → H2'가 바뀜 → H3 계산이 맞지 않음 → 변조 감지!
```

#### 감사 로그 vs 일반 로그

| 구분 | 일반 로그 | 감사 로그 |
|------|---------|---------|
| **수정 가능?** | 로테이션·삭제 가능 | ❌ 절대 불가 |
| **변조 탐지?** | 없음 | 해시 체인으로 탐지 |
| **법적 증거?** | 제한적 | ✅ 법적 효력 |
| **접근 제어?** | 일반적 | 매우 엄격 (읽기도 제한) |
| **보존 기간?** | 30일~1년 | 3년~7년 (법적 의무) |

---

## 5. 비즈니스 로그 (Business Logs)

> **목적: "비즈니스가 어떻게 흘러가고 있는가?"**

### 5.1 트랜잭션 로그 (Transaction Logs)

**정의**: 비즈니스 크리티컬한 **거래·처리 흐름**을 추적

> ⚠️ **DB 트랜잭션 로그(WAL)와 혼동 주의!**
>
> | | DB 트랜잭션 로그 (WAL) | 비즈니스 트랜잭션 로그 |
> |--|---------------------|---------------------|
> | **목적** | DB 데이터 무결성·복구 | 비즈니스 흐름 추적 |
> | **대상** | DB 내부 변경사항 | 주문, 결제, 배송 등 |
> | **관리자** | DBMS가 자동 관리 | 개발자가 직접 기록 |
> | **접근** | DBA만 | 개발자·비즈니스팀 |
> 
> **WAL(Write-Ahead Log)의 원리:**
> ```
> 사용자 요청: "잔고 10만원 → 5만원으로 변경"
>
>   ① WAL에 먼저 기록: "계좌 A: 10만→5만" (로그 선행 기록)
>   ② 실제 데이터 변경: 계좌 A = 5만원
>
>   만약 ② 중에 서버가 죽으면?
>   → 재시작 후 WAL을 읽어서 ② 를 다시 수행 (복구)
>   → 데이터 무결성 보장!
> ```

#### 비즈니스 트랜잭션 로그 예시

```json
{
  "timestamp": "2026-02-24T18:34:00.000Z",
  "type": "business_transaction",
  "transaction_id": "TXN-2026-00123",
  "correlation_id": "ORDER-FLOW-789",
  "flow": "order_to_delivery",
  "current_step": "payment_processed",
  "steps": [
    {
      "step": "order_created",
      "service": "order-service",
      "status": "completed",
      "started_at": "18:34:00.000",
      "completed_at": "18:34:00.500",
      "duration_ms": 500
    },
    {
      "step": "inventory_checked",
      "service": "inventory-service",
      "status": "completed",
      "started_at": "18:34:00.600",
      "completed_at": "18:34:01.200",
      "duration_ms": 600,
      "result": { "available": true, "warehouse": "ICN-01" }
    },
    {
      "step": "payment_processed",
      "service": "payment-service",
      "status": "completed",
      "started_at": "18:34:01.300",
      "completed_at": "18:34:03.500",
      "duration_ms": 2200,
      "result": { "gateway": "stripe", "payment_id": "PAY-abc" }
    },
    {
      "step": "shipping_requested",
      "service": "shipping-service",
      "status": "pending"
    }
  ],
  "amounts": {
    "subtotal": 50000,
    "discount": 5000,
    "tax": 4500,
    "total": 49500,
    "currency": "KRW"
  },
  "customer_id": "CUST-456"
}
```

**트랜잭션 로그의 가치:**
- 📊 단계별 소요 시간 분석 → 병목 식별
- ❌ 어느 단계에서 실패했는지 정확히 파악
- 📈 비즈니스 지표 도출 (주문 성공률, 평균 처리 시간)
- 🔍 고객 문의 시 주문 흐름 즉시 조회

---

### 5.2 사용자 행동 로그 (Behavior / Activity Logs)

**정의**: 사용자의 서비스 이용 패턴, 행동 데이터를 기록

```json
{
  "timestamp": "2026-02-24T18:35:00.000Z",
  "type": "user_activity",
  "user_id": "U-456",
  "session_id": "sess-xyz789",
  "session_start": "2026-02-24T18:20:00.000Z",
  "events": [
    {
      "action": "page_view",
      "page": "/products/electronics",
      "referrer": "/home",
      "duration_s": 45,
      "scroll_depth_pct": 75
    },
    {
      "action": "search",
      "query": "무선 이어폰",
      "results_count": 23,
      "filters_applied": ["brand:samsung", "price:under_100000"]
    },
    {
      "action": "product_view",
      "product_id": "PROD-001",
      "product_name": "Galaxy Buds Pro 3",
      "price": 199000,
      "duration_s": 120
    },
    {
      "action": "add_to_cart",
      "product_id": "PROD-001",
      "quantity": 1,
      "cart_total": 199000
    }
  ],
  "device": {
    "type": "mobile",
    "os": "iOS 19",
    "browser": "Safari 20.0",
    "screen": "1290x2796"
  }
}
```

**행동 로그의 활용:**

| 활용 분야 | 분석 내용 | 질문 |
|----------|---------|------|
| **제품 개선** | 퍼널 분석, 이탈 지점 | "어디서 사용자가 떠나는가?" |
| **개인화** | 추천 시스템, 관심사 분석 | "이 사용자는 무엇에 관심있는가?" |
| **A/B 테스트** | 변형별 전환율 비교 | "어떤 UI가 더 효과적인가?" |
| **이상 탐지** | 비정상 행동 패턴 | "봇인가 사람인가?" |

> ⚠️ **개인정보 주의**: 행동 로그는 GDPR, 개인정보보호법 등의 규제를 받는다.
> 목적 외 사용 금지, 동의 없는 수집 금지, 보존 기간 준수 필수.

---

### 5.3 변경 로그 (Change Logs)

**정의**: 시스템 설정, 인프라 구성, 코드 배포 등의 변경사항을 기록

```json
{
  "timestamp": "2026-02-24T18:36:00.000Z",
  "type": "change",
  "category": "configuration",
  "event": "config_updated",
  "component": "rate-limiter",
  "changes": [
    {
      "parameter": "max_requests_per_minute",
      "before": 100,
      "after": 200,
      "reason": "블랙프라이데이 트래픽 대비"
    },
    {
      "parameter": "burst_size",
      "before": 10,
      "after": 30,
      "reason": "순간 트래픽 허용 확대"
    }
  ],
  "applied_by": {
    "type": "pipeline",
    "id": "deploy-pipeline-v2",
    "triggered_by": "engineer@example.com"
  },
  "deployment": {
    "id": "DEPLOY-2026-089",
    "version": "2.3.1 → 2.4.0",
    "commit": "abc123def"
  },
  "rollback_plan": "DEPLOY-2026-088 (version 2.3.1)"
}
```

**변경 로그가 중요한 이유:**

```
장애의 70~80%는 "뭔가를 변경한 직후"에 발생한다.

  "어제까지 잘 됐는데 오늘 안 된다"
       │
       ▼
  변경 로그 확인: "어제 18시에 rate-limiter 설정 변경"
       │
       ▼
  원인: 새 설정에서 특정 엔드포인트가 누락되어 차단됨
       │
       ▼
  해결: 설정 롤백 → 즉시 복구
```

---

## 6. 전체 요약 비교표

| 로그 종류 | 목적 | 주요 소비자 | 보존 우선순위 | 핵심 질문 |
|-----------|------|-----------|-------------|----------|
| **요청/접근 로그** | 트래픽 패턴 파악 | DevOps, SRE | ⭐⭐⭐ | "어떤 요청이 오고 있나?" |
| **에러 로그** | 장애 원인 분석 | 개발팀 | ⭐⭐⭐ | "뭐가 깨졌나?" |
| **성능/가용성 로그** | 시스템 건강도 | DevOps, SRE | ⭐⭐ | "성능이 정상인가?" |
| **인증 로그** | 접속자 추적 | 보안팀 | ⭐⭐⭐⭐⭐ | "누가 들어왔나?" |
| **접근 제어 로그** | 권한 침해 탐지 | 보안팀 | ⭐⭐⭐⭐⭐ | "권한이 있나?" |
| **감사 로그** | 변경 추적·책임 | 감사/규정준수팀 | ⭐⭐⭐⭐⭐ | "누가 무엇을 바꿨나?" |
| **트랜잭션 로그** | 비즈니스 흐름 | 개발/비즈니스팀 | ⭐⭐⭐⭐ | "거래가 완료됐나?" |
| **행동 로그** | 사용자 분석 | 기획/데이터팀 | ⭐⭐ | "사용자가 뭘 했나?" |
| **변경 로그** | 장애 원인 역추적 | DevOps, 개발팀 | ⭐⭐⭐⭐ | "뭐가 바뀌었나?" |

---

## 정리

```
애플리케이션 로그 종류:
│
├── 운영 로그 (시스템이 잘 돌아가는가?)
│   ├── 요청/접근 로그: CLF → Combined → JSON 구조화 ([모든 요청 기록])
│   ├── 에러 로그: 예외·장애 기록 (모든 예외 ≠ 에러 로그)
│   └── 성능/가용성 로그: 응답 시간, 헬스 체크 (p95/p99 중요)
│
├── 보안 로그 (누가 무엇을 했는가?)
│   ├── 인증 로그: 로그인/MFA/세션 (10가지 필수 이벤트)
│   ├── 접근 제어 로그: 권한 확인 결과 (수평·수직 권한 상승 탐지)
│   └── 감사 로그: 불변·무결·완전·비부인 (해시 체인, 법적 증거)
│
└── 비즈니스 로그 (비즈니스가 어떻게 흘러가는가?)
    ├── 트랜잭션 로그: 주문→결제→배송 흐름 (WAL과 구분!)
    ├── 행동 로그: 사용자 패턴 분석 (GDPR 주의)
    └── 변경 로그: 설정·배포 변경 (장애의 70-80%는 변경 직후)
```
