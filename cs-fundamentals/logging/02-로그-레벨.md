# 로그 레벨 (Log Levels)

---

## 1. 로그 레벨이란?

**로그 레벨(Log Level)** 은 이벤트의 **심각도(Severity)** 를 나타내는 분류 체계이다.

왜 필요한가?

```
모든 로그를 같은 중요도로 취급하면:

  ├── 프로덕션에서 초당 수천 줄의 로그 생성
  ├── 진짜 중요한 에러가 디버그 메시지에 묻힘
  ├── 저장 비용 폭증
  └── 장애 시 원인 찾기가 건초더미에서 바늘 찾기

로그 레벨이 해결하는 것:

  ├── 필터링: 프로덕션에서는 INFO 이상만 수집
  ├── 우선순위: ERROR는 즉시 알림, DEBUG는 무시
  ├── 비용 제어: 필요한 것만 저장
  └── 가독성: 중요도별로 분류된 정보
```

---

## 2. 표준 로그 레벨 체계

### 2.1 전체 계층 구조

대부분의 로깅 프레임워크가 아래 6단계를 따른다. **숫자가 높을수록 심각**하다:

```
높은 심각도
    ▲
    │  ┌──────────────────────────────────────────────────────────┐
    │  │  FATAL / CRITICAL   시스템 사망. 즉시 사람이 개입해야 함     │
    │  ├──────────────────────────────────────────────────────────┤
    │  │  ERROR              기능 실패. 빠른 확인 필요               │
    │  ├──────────────────────────────────────────────────────────┤
    │  │  WARN / WARNING     잠재적 문제. 지금은 괜찮지만 주의        │
    │  ├──────────────────────────────────────────────────────────┤
    │  │  INFO               정상 동작 기록. "잘 되고 있습니다"       │
    │  ├──────────────────────────────────────────────────────────┤
    │  │  DEBUG              개발자용 상세 정보. 프로덕션에선 OFF     │
    │  ├──────────────────────────────────────────────────────────┤
    │  │  TRACE              극도로 상세한 추적. 거의 사용 안 함      │
    │  └──────────────────────────────────────────────────────────┘
    ▼
낮은 심각도
```

### 2.2 Syslog에서의 기원

현대 로그 레벨은 Syslog(RFC 5424)의 Severity에서 유래했다:

| Syslog 숫자 | Syslog 이름 | 현대 로그 레벨 | 설명 |
|------------|------------|-------------|------|
| 0 | Emergency | FATAL | 시스템 사용 불가 |
| 1 | Alert | FATAL | 즉시 조치 필요 |
| 2 | Critical | CRITICAL | 치명적 조건 |
| 3 | Error | ERROR | 에러 조건 |
| 4 | Warning | WARN | 경고 조건 |
| 5 | Notice | — | 정상이지만 중요 (현대에선 잘 안 씀) |
| 6 | Informational | INFO | 정보 메시지 |
| 7 | Debug | DEBUG | 디버그 메시지 |

> 📌 Syslog에는 8단계가 있지만, 현대 프레임워크에서는 Notice를 제거하고 TRACE를 추가해 6단계로 정착했다.

### 2.3 프레임워크별 레벨 비교

| 레벨 | Java (SLF4J/Log4j) | Python (logging) | .NET (ILogger) | JavaScript (winston) |
|------|-------------------|-----------------|----------------|---------------------|
| 최저 | TRACE | — | Trace | silly |
| | DEBUG | DEBUG (10) | Debug | debug |
| | INFO | INFO (20) | Information | info |
| | WARN | WARNING (30) | Warning | warn |
| | ERROR | ERROR (40) | Error | error |
| 최고 | FATAL | CRITICAL (50) | Critical | — |

> 📌 Python에는 TRACE가 없고, 기본 로그 레벨은 WARNING(30)이다.
> 즉, 아무 설정 없이 `logging.info("hello")`를 해도 출력되지 않는다.

---

## 3. 각 레벨 심층 분석

### 🔴 FATAL / CRITICAL

> **"시스템이 죽었거나 죽기 직전이다. 지금 당장 사람이 개입해야 한다."**

```python
# Python
logger.critical("Database cluster unreachable. All connections exhausted. "
                "Application cannot serve any requests. Shutting down.")
```

```java
// Java
logger.fatal("Out of memory. JVM heap exhausted. "
             "Application will terminate. heap_used=4096MB, heap_max=4096MB");
```

**FATAL을 써야 하는 상황:**
| 상황 | 예시 |
|------|------|
| 앱이 시작조차 못 할 때 | DB 연결 설정이 잘못됨, 필수 환경변수 누락 |
| 핵심 의존성 완전 실패 | 메인 DB 클러스터 전체 다운 |
| 복구 불가능한 상태 | OOM(Out of Memory), 디스크 풀 |
| 데이터 손상 가능성 | 트랜잭션 로그 손상 감지 |

**FATAL 이후의 행동:**
1. PagerDuty/Slack 등으로 즉시 알림 발송
2. 온콜 엔지니어 호출
3. 프로세스 안전하게 종료 (graceful shutdown)

---

### 🟠 ERROR

> **"이 작업은 실패했다. 하지만 시스템 전체는 아직 살아있다."**

```python
# Python
logger.error("Payment processing failed",
             extra={
                 "order_id": "ORD-123",
                 "error_type": "GatewayTimeoutError",
                 "gateway": "stripe",
                 "amount": 50000,
                 "retry_count": 3,
                 "max_retries": 3,
                 "duration_ms": 30012
             })
```

```java
// Java
try {
    paymentGateway.charge(order);
} catch (GatewayTimeoutException e) {
    logger.error("Payment failed for order={}, gateway={}, retries exhausted",
                 order.getId(), "stripe", e);
    // 에러를 기록하되, 시스템은 계속 다른 주문을 처리할 수 있음
}
```

**ERROR를 써야 하는 상황:**
| 상황 | 예시 |
|------|------|
| API 호출 최종 실패 | 3번 재시도 후에도 외부 API 응답 없음 |
| 비즈니스 로직 실패 | 재고 부족으로 주문 처리 불가 |
| 데이터 무결성 문제 | 필수 필드 누락, 형식 불일치 |
| 핵심 기능 부분 장애 | 결제는 실패했지만 장바구니는 정상 |

**ERROR ≠ 예외 발생의 모든 경우:**

```python
# ❌ 나쁜 예: 예상된 상황을 ERROR로 기록
try:
    user = db.find_user(user_id)
except UserNotFoundError:
    logger.error("User not found")  # ← WARN이나 INFO가 적절
    return 404

# ✅ 좋은 예: 예상하지 못한 실패만 ERROR로 기록
try:
    user = db.find_user(user_id)
except DatabaseConnectionError as e:
    logger.error("Database connection failed", exc_info=e)  # ← 진짜 ERROR
    return 503
```

---

### 🟡 WARN (WARNING)

> **"지금은 괜찮다. 하지만 이게 계속되면 문제가 된다."**

```python
# Python
logger.warning("Disk usage at 85%%. Threshold is 90%%.",
               extra={"partition": "/data", "free_gb": 15, "total_gb": 100})

logger.warning("External API slow response",
               extra={"api": "geocoding-service", "response_time_ms": 4500,
                      "threshold_ms": 3000, "retrying": True})

logger.warning("Using deprecated API endpoint",
               extra={"endpoint": "/api/v1/users", "replacement": "/api/v2/users",
                      "deprecation_date": "2026-06-01"})
```

**WARN을 써야 하는 상황:**
| 상황 | 예시 |
|------|------|
| 리소스 임계치 접근 | 디스크 85%, 메모리 90%, 커넥션 풀 80% |
| 재시도 발생 (아직 성공) | API 첫 시도 실패, 재시도로 성공 |
| Deprecated 사용 | 곧 제거될 API/라이브러리 사용 |
| 설정 미흡 | fallback 값 사용 중 |
| 성능 저하 | 응답 시간이 SLA 임계치 접근 |

**WARN의 핵심: "아직 실패는 아니지만, 사람이 알아야 한다"**

---

### 🟢 INFO

> **"정상적으로 잘 작동하고 있다. 중요한 비즈니스 이벤트를 기록한다."**

```python
# Python
logger.info("Application started",
            extra={"version": "2.3.1", "environment": "production",
                   "port": 8080, "config": "application-prod.yml"})

logger.info("User login successful",
            extra={"user_id": "U-456", "method": "OAuth2",
                   "ip": "192.168.1.100", "session_id": "sess-abc"})

logger.info("Order created",
            extra={"order_id": "ORD-789", "items_count": 3,
                   "total": 55000, "currency": "KRW"})

logger.info("Scheduled job completed",
            extra={"job": "daily-report-generation", "duration_s": 45,
                   "records_processed": 12500})
```

**INFO를 써야 하는 상황:**
| 상황 | 예시 |
|------|------|
| 앱 생명주기 | 시작, 종료, 설정 로드 완료 |
| 사용자 행동 | 로그인, 로그아웃, 핵심 기능 사용 |
| 비즈니스 이벤트 | 주문 생성, 결제 완료, 배송 시작 |
| 스케줄 작업 | 배치 작업 시작/완료, 결과 요약 |
| 외부 연동 | DB 연결 성공, 외부 API 연동 확인 |

**INFO는 프로덕션에서 "이 시스템이 정상임을 증명하는 증거"다.**

---

### 🔵 DEBUG

> **"개발자만 보면 되는 상세한 내부 동작 정보."**

```python
# Python
logger.debug("Cache lookup result",
             extra={"key": "user:456:profile", "hit": False,
                    "ttl_remaining_s": 0, "fallback": "database"})

logger.debug("SQL query executed",
             extra={"query": "SELECT * FROM users WHERE id = ?",
                    "params": ["U-456"], "rows_returned": 1,
                    "execution_time_ms": 12})

logger.debug("Request payload validated",
             extra={"endpoint": "POST /api/orders",
                    "fields_validated": 8, "validation_time_ms": 2})
```

**DEBUG의 규칙:**

```
⚠️ 프로덕션에서는 기본적으로 OFF

  이유 1: 성능 — 초당 수천 줄의 디버그 로그는 I/O 병목
  이유 2: 비용 — 저장소 비용 폭증
  이유 3: 보안 — 상세 정보가 공격자에게 노출될 위험
  이유 4: 노이즈 — 진짜 중요한 로그가 묻힘

  예외: 프로덕션 장애 시 일시적으로 특정 모듈만 DEBUG 활성화
        → 원인 파악 후 즉시 다시 OFF
```

---

### ⚪ TRACE

> **"코드의 한 줄 한 줄을 추적하는 가장 상세한 레벨."**

```python
# Python (보통 커스텀으로 추가해야 함)
logger.trace("Entering method calculateDiscount",
             extra={"input_price": 50000, "user_tier": "gold",
                    "applicable_coupons": ["WINTER10", "VIP20"]})

logger.trace("Discount calculation step 1: base discount",
             extra={"tier_discount_rate": 0.15, "discounted_price": 42500})

logger.trace("Exiting method calculateDiscount",
             extra={"final_price": 40000, "total_discount": 10000})
```

**TRACE를 쓸 때:**
- 매우 복잡한 알고리즘 디버깅
- 데이터 흐름을 한 단계씩 추적해야 할 때
- 로컬 개발에서만 사용하고 커밋하지 않는 것이 이상적

---

## 4. 레벨 선택 의사결정 트리

어떤 레벨을 써야 할지 헷갈릴 때 이 플로우차트를 따르자:

```
이벤트가 발생했다
     │
     ▼
시스템이 더 이상 동작할 수 없는가?
     │
     ├── YES → 🔴 FATAL
     │
     └── NO
          │
          ▼
     이 작업이 실패했는가?
          │
          ├── YES ─── 재시도로 해결됐는가?
          │               │
          │               ├── YES → 🟡 WARN (재시도 성공했지만 첫 시도 실패 기록)
          │               │
          │               └── NO → 🟠 ERROR (최종 실패)
          │
          └── NO
               │
               ▼
          잠재적 문제가 있는가? (리소스 부족, 성능 저하, deprecated 사용)
               │
               ├── YES → 🟡 WARN
               │
               └── NO
                    │
                    ▼
               비즈니스적으로 의미 있는 이벤트인가?
                    │
                    ├── YES → 🟢 INFO
                    │
                    └── NO
                         │
                         ▼
                    개발자가 디버깅에 필요한 정보인가?
                         │
                         ├── YES → 🔵 DEBUG
                         │
                         └── NO ─── 코드 흐름 추적이 필요한가?
                                        │
                                        ├── YES → ⚪ TRACE
                                        │
                                        └── NO → 로그하지 않아도 됨
```

---

## 5. 레벨 필터링의 원리

### 5.1 계층적 필터링

로그 레벨을 `INFO`로 설정하면, **INFO 이상만 출력**된다:

```
설정 레벨: INFO

  FATAL    ✅ 출력
  ERROR    ✅ 출력
  WARN     ✅ 출력
  INFO     ✅ 출력    ← 설정한 레벨
  DEBUG    ❌ 무시
  TRACE    ❌ 무시
```

```
설정 레벨: ERROR

  FATAL    ✅ 출력
  ERROR    ✅ 출력    ← 설정한 레벨
  WARN     ❌ 무시
  INFO     ❌ 무시
  DEBUG    ❌ 무시
  TRACE    ❌ 무시
```

### 5.2 모듈별 레벨 설정

실전에서는 **모듈(패키지)별**로 다른 레벨을 설정한다:

```yaml
# 로그 설정 예시 (YAML)
logging:
  level:
    root: WARN                        # 전체 기본: WARN 이상만
    com.myapp.auth: INFO              # 인증 모듈: INFO 이상
    com.myapp.payment: DEBUG          # 결제 모듈: DEBUG 이상 (문제 조사 중)
    org.hibernate.SQL: DEBUG          # DB 쿼리: DEBUG (쿼리 확인용)
    org.springframework: WARN         # 프레임워크: WARN 이상만
```

```
이렇게 하면:

  auth 모듈     → INFO, WARN, ERROR, FATAL 출력
  payment 모듈  → DEBUG, INFO, WARN, ERROR, FATAL 출력  ← 임시로 상세하게
  Spring 내부   → WARN, ERROR, FATAL만 출력              ← 프레임워크 노이즈 제거
  나머지 전부    → WARN, ERROR, FATAL만 출력
```

---

## 6. 동적 로그 레벨 변경 (Runtime Configuration)

### 6.1 왜 필요한가?

```
상황: 프로덕션에서 간헐적 버그 발생

  기존 방법:
  1. 설정 파일에서 로그 레벨을 DEBUG로 변경
  2. 앱 재배포 또는 재시작     ← 🔥 다운타임 발생!
  3. 버그 재현 대기
  4. 로그 확인
  5. 다시 INFO로 변경, 재배포   ← 🔥 또 다운타임!

  동적 변경:
  1. API 호출로 특정 모듈만 DEBUG로 변경  ← ✅ 무중단
  2. 버그 재현 및 로그 확인
  3. API 호출로 다시 INFO로 복원          ← ✅ 무중단
```

### 6.2 구현 방법들

#### Spring Boot Actuator (Java)

```bash
# 현재 로그 레벨 확인
curl http://localhost:8080/actuator/loggers/com.myapp.payment

# 실시간으로 DEBUG로 변경
curl -X POST http://localhost:8080/actuator/loggers/com.myapp.payment \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel": "DEBUG"}'

# 조사 완료 후 INFO로 복원
curl -X POST http://localhost:8080/actuator/loggers/com.myapp.payment \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel": "INFO"}'
```

#### Python (런타임 변경)

```python
import logging

# 특정 로거의 레벨 동적 변경
logger = logging.getLogger("myapp.payment")
logger.setLevel(logging.DEBUG)  # 즉시 적용, 재시작 불필요

# FastAPI 엔드포인트로 노출
@app.post("/admin/log-level")
async def change_log_level(module: str, level: str):
    numeric_level = getattr(logging, level.upper(), None)
    if numeric_level is None:
        raise HTTPException(400, f"Invalid level: {level}")
    logging.getLogger(module).setLevel(numeric_level)
    return {"module": module, "level": level, "status": "changed"}
```

> ⚠️ **보안 주의**: 동적 로그 레벨 변경 API는 반드시 인증·인가를 거쳐야 한다.
> 공격자가 DEBUG를 활성화하면 민감 정보가 로그에 노출될 수 있다.

---

## 7. 로그 레벨과 성능

### 7.1 로깅의 비용

로깅은 공짜가 아니다. 매 로그 호출마다:

```
  logger.info("message")
       │
       ├── 1. 레벨 필터 체크         →  ~1ns
       ├── 2. 메시지 문자열 생성      →  ~100ns ~ 1μs
       ├── 3. 컨텍스트 수집           →  ~500ns (스택 트레이스 포함 시 ~50μs)
       ├── 4. 포맷팅                 →  ~1μs
       └── 5. I/O (파일/네트워크 쓰기) →  ~10μs ~ 1ms   ← 가장 비쌈!
            └── 동기 I/O의 경우 스레드가 차단될 수 있음
```

### 7.2 레벨별 볼륨 차이

```
              볼륨 (로그/초)
                │
  10,000 ─  ┌───┐
             │   │
   1,000 ─  │   │  ┌───┐
             │   │  │   │
     100 ─  │   │  │   │  ┌───┐
             │   │  │   │  │   │
      10 ─  │   │  │   │  │   │  ┌───┐         ┌───┐
             │   │  │   │  │   │  │   │  ┌───┐  │   │
       1 ─  │   │  │   │  │   │  │   │  │   │  │   │
             └───┘  └───┘  └───┘  └───┘  └───┘  └───┘
            TRACE  DEBUG   INFO   WARN   ERROR  FATAL
```

### 7.3 성능 최적화 팁

```python
# ❌ 나쁜 패턴: 레벨과 무관하게 항상 비용 발생
logger.debug(f"Processing user {user.to_json()}")
# → user.to_json()은 DEBUG가 꺼져 있어도 실행됨!

# ✅ 좋은 패턴: 레벨 체크 후 비용 발생
if logger.isEnabledFor(logging.DEBUG):
    logger.debug("Processing user %s", user.to_json())

# ✅ 더 좋은 패턴: 지연 평가 (lazy evaluation)
logger.debug("Processing user %s", user.id)  # 포맷팅이 출력 시에만 발생
```

```java
// Java - SLF4J의 지연 평가
// ❌ 나쁜 패턴
logger.debug("User details: " + user.toString());  // 항상 문자열 결합 발생

// ✅ 좋은 패턴: 플레이스홀더 사용
logger.debug("User details: {}", user);  // DEBUG 활성화 시에만 toString() 호출
```

---

## 8. 환경별 로그 레벨 전략

| 환경 | 권장 최소 레벨 | 이유 | 보존 기간 |
|------|-------------|------|----------|
| **로컬 개발** | `DEBUG` | 개발자가 모든 정보 필요 | 세션 종료 시 삭제 |
| **테스트/QA** | `DEBUG` | 테스트 실패 원인 추적 | 테스트 사이클 동안 |
| **스테이징** | `INFO` | 프로덕션과 유사하게 운영 | 1~2주 |
| **프로덕션** | `INFO` 또는 `WARN` | 성능과 저장 공간 절약 | 정책에 따라 30일~1년 |
| **장애 시 프로덕션** | `DEBUG` (일시적, 특정 모듈만) | 원인 추적 후 즉시 복원 | 장애 해결까지만 |

---

## 9. 흔한 안티패턴과 올바른 사용

### 9.1 ❌ 예외를 삼키기 (Swallowing Exceptions)

```python
# ❌ 예외를 잡고 아무것도 안 함
try:
    process_order(order)
except Exception:
    pass  # 🔥 에러가 사라짐! 원인 추적 불가능

# ✅ 최소한 로그는 남겨야 함
try:
    process_order(order)
except Exception as e:
    logger.error("Failed to process order %s", order.id, exc_info=e)
    raise  # 또는 적절한 에러 처리
```

### 9.2 ❌ 잡고-로그하고-다시 던지기 (Catch-Log-Throw)

```java
// ❌ 여러 계층에서 같은 예외를 반복 로그
// Layer 1
try { dao.save(entity); }
catch (SQLException e) {
    logger.error("DB error", e);
    throw new ServiceException(e);  // 같은 에러가 상위에서 또 로그됨
}
// Layer 2
try { service.process(data); }
catch (ServiceException e) {
    logger.error("Service error", e);  // 🔥 중복 로그!
    throw new ControllerException(e);
}

// ✅ 한 곳에서만 로그하고, 나머지는 전파만
// → 최종 처리 지점(Controller 또는 Global Exception Handler)에서만 로그
```

### 9.3 ❌ 잘못된 레벨 사용

```python
# ❌ 정상 동작을 ERROR로 기록 → 불필요한 알림 폭증
logger.error("User %s not found", user_id)  # → 404는 정상적인 응답임

# ✅ 올바른 레벨
logger.info("User %s not found, returning 404", user_id)

# ❌ 심각한 문제를 DEBUG로 기록 → 프로덕션에서 안 보임
logger.debug("Database connection pool exhausted!")  # 이건 ERROR여야 함

# ✅ 올바른 레벨
logger.error("Database connection pool exhausted! active=%d, max=%d",
             active_count, max_count)
```

### 9.4 ❌ 루프 안에서 과다 로깅

```python
# ❌ 10만 건 처리 시 10만 줄의 로그 생성
for item in items:  # len(items) = 100,000
    logger.info("Processing item %s", item.id)  # 🔥 I/O 병목!
    process(item)

# ✅ 요약 로그로 대체
logger.info("Starting batch processing", extra={"total_items": len(items)})
processed = 0
for item in items:
    process(item)
    processed += 1
    if processed % 10000 == 0:  # 1만 건마다 진행 상황
        logger.info("Batch progress: %d/%d", processed, len(items))
logger.info("Batch completed", extra={"processed": processed, "duration_s": elapsed})
```

---

## 정리

```
로그 레벨이란?
├── 정의: 이벤트의 심각도를 나타내는 분류 체계
├── 기원: Syslog RFC 5424의 Severity 레벨에서 유래
├── 6단계: TRACE → DEBUG → INFO → WARN → ERROR → FATAL
│
├── 레벨별 핵심:
│   ├── FATAL: 시스템 사망, 즉시 사람 개입
│   ├── ERROR: 작업 실패, 빠른 확인
│   ├── WARN:  잠재적 문제, 주의 필요
│   ├── INFO:  정상 동작 증거
│   ├── DEBUG: 개발자용, 프로덕션 OFF
│   └── TRACE: 극도로 상세, 거의 안 씀
│
├── 실전 기술:
│   ├── 계층적 필터링: 설정 레벨 이상만 출력
│   ├── 모듈별 설정: 패키지별 다른 레벨 부여
│   ├── 동적 변경: 재시작 없이 레벨 변경
│   └── 성능 최적화: 지연 평가, 비동기 I/O
│
└── 안티패턴:
    ├── 예외 삼키기 (pass)
    ├── Catch-Log-Throw (중복 로그)
    ├── 잘못된 레벨 선택
    └── 루프 내 과다 로깅
```
