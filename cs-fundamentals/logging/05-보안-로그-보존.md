# 보안 로그 보존 (Security Log Retention)

---

## 1. 왜 보안 로그를 보존해야 하는가?

### 1.1 보안 사고의 현실

```
공격자가 시스템에 침입한 사실을 발견하기까지 걸리는 시간:

  ┌──────────────────────────────────────────────┐
  │   평균 체류 시간 (Dwell Time)                   │
  │                                                │
  │   IBM 2024 보고서 기준: 약 204일 (약 7개월)      │
  │                                                │
  │   즉, 1월에 침입했으면 8월에야 발견              │
  └──────────────────────────────────────────────┘
```

**이것이 의미하는 것:**

```
만약 로그를 30일만 보존한다면?
  │
  ├── 1월: 공격자 침입 (로그에 흔적 남김)
  ├── 2월: 30일 경과 → 1월 로그 삭제됨  🗑️
  ├── ...
  ├── 8월: 침입 발견! "언제부터 들어왔지?"
  │         8월 로그만 있음 → 최초 침입 시점 추적 불가
  │         공격 범위 파악 불가 → 어디까지 뚫렸는지 모름
  │         법적 증거 확보 불가 → 소송·신고에 활용 못 함
  └── 결론: 로그가 없으면 "암흑 속에서 수사"하는 것과 같다
```

### 1.2 보존의 3가지 목적

```
┌─────────────────┬────────────────────┬─────────────────────┐
│   사고 대응       │   법적 규정 준수     │    포렌식 분석       │
│   (Incident       │   (Compliance)      │    (Forensics)      │
│    Response)      │                     │                     │
├─────────────────┼────────────────────┼─────────────────────┤
│ "언제, 어떻게     │ "법이 요구하는       │ "법정에서 증거로     │
│  침입했는가?"     │  기간만큼 보관"      │  사용할 수 있는가?"  │
│                   │                     │                     │
│ • 타임라인 재구성  │ • 벌금·제재 회피     │ • 증거 보전          │
│ • 영향 범위 파악  │ • 감사 대비         │ • 관리 연속성         │
│ • 재발 방지 대책  │ • 인증 유지         │ • 비부인(否認) 보장   │
└─────────────────┴────────────────────┴─────────────────────┘
```

---

## 2. 국제 표준과 가이드라인

### 2.1 NIST SP 800-92: 컴퓨터 보안 로그 관리 가이드

NIST(미국 국립표준기술원)의 핵심 로그 관리 문서. 보안 로그 관리의 **근본 교과서**.

#### 핵심 요구사항

```
NIST SP 800-92의 로그 관리 생명주기:

  ① 생성 (Generation)
     └─ 어떤 이벤트를 로그로 남길 것인가?
        └─ 너무 적으면 탐지 실패, 너무 많으면 노이즈

  ② 전송 (Transmission)
     └─ 로그를 안전하게 중앙으로 보내는가?
        └─ TLS 암호화, 네트워크 장애 시 버퍼링

  ③ 저장 (Storage)
     └─ 무결성을 보장하며 저장하는가?
        └─ 접근 제어, 변조 탐지, WORM 스토리지

  ④ 분석 (Analysis)
     └─ 정기적으로 로그를 검토하는가?
        └─ 자동 상관 분석, 이상 탐지, 규칙 기반 알림

  ⑤ 폐기 (Disposal)
     └─ 보존 기간 만료 후 안전하게 삭제하는가?
        └─ 복구 불가능한 삭제, 삭제 기록 남김
```

#### NIST SP 800-53 AU (감사·책임) 제어 항목

| 제어 ID | 이름 | 핵심 내용 |
|---------|------|---------|
| AU-2 | Event Logging | 감사 대상 이벤트를 정의하고 기록 |
| AU-3 | Content of Audit Records | 누가·무엇을·언제·어디서·결과 포함 |
| AU-4 | Audit Log Storage Capacity | 충분한 저장 공간 확보, 용량 초과 시 알림 |
| AU-5 | Response to Audit Failures | 로깅 실패 시 알림·대응 (기록을 멈추면 안 됨) |
| AU-6 | Audit Record Review | 정기적 로그 검토 및 보고 |
| AU-8 | Time Stamps | 신뢰할 수 있는 시간 소스 (NTP) 사용 |
| AU-9 | Protection of Audit Info | 감사 정보 무단 접근·수정·삭제 방지 |
| AU-10 | Non-repudiation | 행위자가 자신의 행위를 부인할 수 없게 보장 |
| AU-11 | Audit Record Retention | 보존 정책에 따라 로그 보존 |
| AU-12 | Audit Record Generation | 모든 시스템 컴포넌트에서 감사 기록 생성 |

### 2.2 OWASP 로깅 가이드라인

| 원칙 | 설명 |
|------|------|
| **What to log** | 입력 검증 실패, 인증 성공/실패, 인가 실패, 세션 관리 이벤트, 앱 오류, 관리자 기능 사용 |
| **What NOT to log** | 비밀번호, 카드번호, 세션 ID, 개인식별정보(PII), 설정된 제외 항목 |
| **How to log** | 공통 로깅 프레임워크 사용, 일관된 인코딩, 로그 주입(injection) 방지 |
| **Where to log** | 별도의 전용 시스템, 앱 서버와 분리, 접근 제어 적용 |

---

## 3. 반드시 기록해야 할 이벤트

### 3.1 Cyber Kill Chain 단계별 필수 로그

공격의 각 단계에서 **어떤 로그가 흔적을 남기는지** 이해하면, 어떤 로그를 반드시 보존해야 하는지가 명확해진다:

```
Kill Chain 단계              필수 로그 소스                    탐지 가능 시점
─────────────────────────── ──────────────────────────────── ──────────────
① 정찰 (Reconnaissance)     웹 접근 로그, DNS 쿼리 로그,       공격 전
                             포트 스캔 탐지 로그                 (선제 탐지)

② 무기화 (Weaponization)     (외부 활동 → 우리 로그에 안 남음)   탐지 불가

③ 전달 (Delivery)           이메일 로그, 웹 프록시 로그,        침입 시점
                             방화벽 로그, 엔드포인트 로그

④ 악용 (Exploitation)       애플리케이션 에러 로그,             침입 직후
                             OS 이벤트 로그, IDS/IPS 로그

⑤ 설치 (Installation)       파일 시스템 변경 로그,              지속성 확보
                             레지스트리 변경 로그,
                             신규 서비스/프로세스 생성 로그

⑥ C2 (Command & Control)    DNS 로그 (비정상 쿼리),            내부 활동
                             네트워크 플로우 로그,
                             프록시 로그 (비정상 외부 통신)

⑦ 목표 달성                 데이터 접근 로그, DB 쿼리 로그,     사후 추적
   (Actions on Objectives)  파일 다운로드 로그,
                             권한 변경 로그
```

### 3.2 이벤트 카테고리별 필수 기록 항목

| 카테고리 | 반드시 기록해야 할 이벤트 | 왜 필수인가? |
|----------|----------------------|------------|
| **인증** | 로그인 성공/실패, MFA 시도, 비밀번호 변경/재설정, 계정 잠금/해제, 세션 생성/만료, API 키 발급/폐기 | 무차별 대입, 계정 탈취, 크리덴셜 스터핑 탐지 |
| **인가** | 접근 허용/거부, 권한 변경, 역할 부여/제거, 관리자 권한 사용 | 권한 상승, 내부자 위협 탐지 |
| **데이터 접근** | 민감 데이터 조회/수정/삭제/다운로드, 대량 데이터 추출, 암호화/복호화 이벤트 | 데이터 유출, 내부자 탈취 탐지 |
| **시스템 변경** | 설정 변경, 보안 정책 변경, 방화벽 규칙 변경, 새 사용자 계정 생성, 감사 로그 설정 변경 | 공격자의 지속성 확보·환경 변경 탐지 |
| **네트워크** | 방화벽 허용/차단, VPN 연결, DNS 쿼리(비정상), 아웃바운드 대량 전송 | 측면 이동, C2 통신, 데이터 유출 탐지 |

---

## 4. 보존 기간: 규정별 비교

### 4.1 국내 규정

| 규정 | 대상 | 보존 기간 | 핵심 요구사항 |
|------|------|----------|-------------|
| **개인정보보호법** (PIPA) | 개인정보 처리 시스템 | **최소 1년** (5만 건 이상 처리 시 **2년**) | 접속기록(접속자 ID, 접속일시, 접속지 정보, 처리 내역) |
| **정보통신망법** | 통신사업자 | **최소 3개월** ~ 12개월 | 로그인 기록, 통신사실 확인 자료 |
| **전자금융거래법** | 금융기관 | **5년** | 전자금융거래 관련 접속 기록 |
| **국가정보보안기본지침** | 정부기관 | **최소 6개월** | 시스템 접근 기록, 보안 이벤트 |

> 📌 **개인정보보호법 접속기록 세부 요구사항:**
> 
> 접속기록에 반드시 포함해야 하는 항목:
> - 접속한 자의 **계정(ID)**
> - **접속 일시**
> - 접속한 자의 **정보** (IP 등)
> - 수행한 **업무 내용** (조회, 변경, 삭제, 다운로드 등)
> 
> 또한 매월 1회 이상 접속기록을 점검하여 개인정보의 오·남용, 분실, 도난, 유출, 위·변조, 훼손 여부를 확인해야 한다.

### 4.2 해외 규정

| 규정 | 적용 지역/산업 | 보존 기간 | 대상 |
|------|-------------|----------|------|
| **PCI DSS** | 카드 결제 사업자 | **최소 1년** (최근 3개월은 즉시 접근 가능) | 감사 추적 기록 |
| **HIPAA** | 미국 의료 | **6년** | 보안 관련 문서·기록 |
| **SOX** | 미국 상장기업 | **7년** | 재무 관련 감사 기록 |
| **GDPR** | EU 개인정보 | **명시적 기간 없음** (목적 달성 시 삭제) | 처리 활동 기록 |
| **FISMA** | 미국 연방기관 | **3년** | 시스템 보안 기록 |

### 4.3 보존 기간 결정 의사결정 트리

```
우리 시스템에 적용되는 규정은 무엇인가?
     │
     ├── 규정이 여러 개인가?
     │      │
     │      └── YES → 가장 긴 기간을 적용
     │              예: PIPA(1년) + 전자금융거래법(5년) → 5년 적용
     │
     ├── 규정에 명시된 기간이 없는가? (예: GDPR)
     │      │
     │      └── YES → 업계 모범 사례 기준
     │              일반: 최소 1년
     │              금융/의료: 3~7년
     │              정부: NIST 권장 기준 따름
     │
     └── 최종 결정 = max(법적 요구, 사고 대응 필요, 비즈니스 필요)
         │
         └── 일반 권장: 최소 1년, 가능하면 2~3년
```

---

## 5. 티어드 스토리지 전략 (Tiered Storage)

### 5.1 왜 티어드 스토리지인가?

```
문제: 모든 로그를 빠른 스토리지에 보관하면?

  일일 로그 볼륨:   10GB
  × 보존 기간:      × 365일 (1년)
  = 총 저장량:      3.65TB
  × 빠른 SSD 비용:  × $0.10/GB/월
  = 연간 비용:      ≈ $4,380

  하지만 실제로 6개월 전 로그를 검색하는 빈도는?
  → 거의 없음 (사고 시에만)
  → 비용 대비 효율이 매우 낮음

해결: 시간에 따라 저렴한 스토리지로 단계적 이동
```

### 5.2 3-티어 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                                                               │
│  HOT (핫 티어)        │  WARM (웜 티어)       │  COLD (콜드 티어) │
│  0 ~ 30일             │  31 ~ 180일           │  181일 ~ 보존 만료 │
│                       │                       │                  │
│  📊 실시간 분석        │  🔍 필요 시 검색       │  📦 장기 보관      │
│     대시보드            │     사고 조사          │     규정 준수      │
│     알림               │     트렌드 분석         │     포렌식        │
│                       │                       │                  │
│  저장소:              │  저장소:               │  저장소:           │
│  Elasticsearch        │  S3 Standard          │  S3 Glacier       │
│  Splunk Hot           │  Azure Cool Blob      │  Azure Archive     │
│  Loki                 │                       │  GCS Coldline      │
│                       │                       │                  │
│  검색 속도: <1초       │  검색 속도: 수초~수분   │  검색 속도: 수시간  │
│  비용: $$$            │  비용: $$              │  비용: $           │
│                       │                       │                  │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 비용 비교 (클라우드 기준, 근사치)

| 티어 | 스토리지 예 | 비용 (GB/월) | 검색 속도 | 사용 시나리오 |
|------|-----------|------------|----------|-------------|
| **Hot** | ES, Splunk | $0.10~0.30 | 즉시 (<1초) | 실시간 모니터링, 알림 |
| **Warm** | S3 Standard | $0.02~0.05 | 수초 | 사고 조사, 트렌드 분석 |
| **Cold** | S3 Glacier | $0.004~0.01 | 수 시간 | 규정 준수, 포렌식 |

```
비용 절감 효과:

  모두 Hot으로 1년 보존:     3.65TB × $0.15 × 12개월 = $6,570/년
  
  티어드 전략:
    Hot  (30일):   300GB × $0.15 = $ 45/월 = $  540/년
    Warm (150일): 1.5TB × $0.03  = $ 45/월 = $  540/년
    Cold (185일): 1.85TB × $0.007 = $ 13/월 = $  156/년
                                        총   = $1,236/년

  절감: 약 81% 비용 절감!
```

### 5.4 자동 이동 정책 (Lifecycle Policy)

```json
{
  "lifecycle_policy": {
    "rules": [
      {
        "name": "hot_to_warm",
        "description": "30일 경과 시 Warm으로 이동",
        "condition": { "age_days": 30 },
        "action": {
          "move_to": "warm_storage",
          "compress": true,
          "format": "parquet"
        }
      },
      {
        "name": "warm_to_cold",
        "description": "180일 경과 시 Cold로 이동",
        "condition": { "age_days": 180 },
        "action": {
          "move_to": "cold_storage",
          "compress": true
        }
      },
      {
        "name": "cold_to_delete",
        "description": "보존 기간 만료 시 안전 삭제",
        "condition": { "age_days": 730 },
        "action": {
          "delete": true,
          "secure_wipe": true,
          "log_deletion": true
        }
      }
    ]
  }
}
```

---

## 6. 로그 보호 (Log Protection)

### 6.1 왜 로그 자체를 보호해야 하는가?

```
공격자의 목표 중 하나: 흔적 지우기

  공격 순서:
  ① 시스템 침입
  ② 목표 달성 (데이터 탈취, 시스템 파괴)
  ③ 🧹 로그 삭제/변조  ← 자신의 흔적 제거
  ④ 탈출
  
  만약 로그가 보호되지 않으면:
  → 공격자가 로그를 삭제 → 침입 증거 사라짐
  → 공격자가 로그를 변조 → 잘못된 방향으로 수사
```

### 6.2 보호 계층

```
┌──────────────────────────────────────────────────────────┐
│                    로그 보호 5계층                         │
│                                                           │
│  ⑤ 삭제 방지 (Deletion Prevention)                        │
│     └─ WORM 스토리지 (Write Once Read Many)               │
│     └─ 법적 보류 (Legal Hold)                             │
│     └─ 보존 잠금 (Retention Lock)                         │
│                                                           │
│  ④ 변조 탐지 (Tamper Detection)                           │
│     └─ 해시 체인 (각 레코드의 해시를 다음 레코드에 포함)       │
│     └─ Merkle 트리 (대량 레코드 무결성 일괄 검증)            │
│     └─ 디지털 서명 (로그 블록 단위 서명)                     │
│                                                           │
│  ③ 전송 보호 (Transit Protection)                         │
│     └─ TLS 암호화 (수집기까지 경로 암호화)                   │
│     └─ 상호 TLS (mTLS, 양방향 인증)                        │
│                                                           │
│  ② 접근 제어 (Access Control)                             │
│     └─ 최소 권한 원칙 (읽기만 허용, 삭제 불가)               │
│     └─ 역할 분리 (로그 생성자 ≠ 로그 관리자 ≠ 로그 분석자)    │
│     └─ 로그 접근 자체를 로그로 기록 (meta-logging)           │
│                                                           │
│  ① 원본 분리 (Source Separation)                           │
│     └─ 로그 서버를 앱 서버와 물리적/논리적으로 분리            │
│     └─ 앱 서버 해킹 ≠ 로그 서버 해킹                        │
│     └─ 별도 네트워크 세그먼트                               │
└──────────────────────────────────────────────────────────┘
```

### 6.3 WORM 스토리지 (Write Once Read Many)

```
WORM의 원리:
 
  일반 스토리지:          WORM 스토리지:
  ┌──────────┐          ┌──────────┐
  │ 쓰기 ✅   │          │ 쓰기 ✅   │  ← 최초 1회만
  │ 읽기 ✅   │          │ 읽기 ✅   │
  │ 수정 ✅   │          │ 수정 ❌   │  ← 절대 불가
  │ 삭제 ✅   │          │ 삭제 ❌   │  ← 보존 기간 내 불가
  └──────────┘          └──────────┘
  
  클라우드 구현:
  ├── AWS S3 Object Lock (Governance/Compliance 모드)
  ├── Azure Immutable Blob Storage
  └── GCP Retention Policy with Bucket Lock
```

---

## 7. 포렌식 준비 (Forensic Readiness)

### 7.1 포렌식 준비란?

> **"사고가 나기 전에, 사고 조사에 필요한 증거를 확보할 수 있도록 미리 준비하는 것"**

사고가 난 후 "아, 이 로그를 남겼어야 했는데..." 하면 이미 늦다.

### 7.2 포렌식 증거로서의 로그 요건

```
법정에서 로그를 증거로 사용하려면 다음을 증명해야 한다:

  ☑ 진정성 (Authenticity)
    └─ 이 로그는 실제 시스템에서 생성된 것이 맞는가?
    └─ 증명: 디지털 서명, 생성 과정 문서화

  ☑ 무결성 (Integrity)
    └─ 생성 이후 변조되지 않았는가?
    └─ 증명: 해시 체인, WORM 스토리지, 접근 기록

  ☑ 신뢰성 (Reliability)
    └─ 시스템이 정상 작동 중에 생성된 것인가?
    └─ 증명: 시스템 헬스 로그, NTP 동기화 증거

  ☑ 관리 연속성 (Chain of Custody)
    └─ 생성부터 현재까지 누가 접근했고, 어떻게 관리되었는가?
    └─ 증명: 접근 로그, 이관 기록, 보관 절차 문서
```

### 7.3 타임스탬프의 중요성: NTP 동기화

```
분산 시스템에서 시계가 어긋나면?

  서버 A (시계: 18:30:00):  "로그인 성공"
  서버 B (시계: 18:29:55):  "데이터 삭제"  ← 5초 빠름

  타임라인:
    18:29:55 데이터 삭제 (서버 B)
    18:30:00 로그인 성공 (서버 A)

  → "로그인 전에 데이터가 삭제됨?!" → 인과관계 역전 → 잘못된 분석

  해결: 모든 서버를 NTP (Network Time Protocol)로 동기화
  └─ 1ms 이내의 시간 오차 보장
  └─ UTC 기준으로 기록, 표시할 때만 로컬 시간대 적용
```

---

## 8. 민감 정보 처리

### 8.1 로그에 기록하면 안 되는 것

```
🚫 절대 금지 목록:

  ┌────────────────────┬────────────────────────────────────┐
  │ 민감 정보           │ 대신 기록할 것                       │
  ├────────────────────┼────────────────────────────────────┤
  │ 비밀번호            │ "password_provided": true           │
  │ 평문 토큰/API 키    │ "token_prefix": "eyJh...", len=256 │
  │ 신용카드 번호        │ "card_last4": "5678"               │
  │ 주민등록번호         │ "has_national_id": true            │
  │ 건강 정보           │ "has_health_record": true          │
  │ 생체 정보           │ "biometric_type": "fingerprint"    │
  │ 세션 ID 전체        │ "session_hash": "a3f2..."          │
  │ 전체 요청 본문       │ "body_size": 1024, "content_type"  │
  └────────────────────┴────────────────────────────────────┘
```

### 8.2 프로그래밍적 보호

```python
# Python - 민감 필드 자동 마스킹
import re

SENSITIVE_PATTERNS = {
    r'"password"\s*:\s*"[^"]*"': '"password": "***REDACTED***"',
    r'"ssn"\s*:\s*"\d{6}-\d{7}"': '"ssn": "***REDACTED***"',
    r'"card_number"\s*:\s*"\d{13,19}"': '"card_number": "***REDACTED***"',
    r'"token"\s*:\s*"[A-Za-z0-9._-]{20,}"': '"token": "***REDACTED***"',
}

def sanitize_log(message: str) -> str:
    for pattern, replacement in SENSITIVE_PATTERNS.items():
        message = re.sub(pattern, replacement, message)
    return message

# 사용
log_entry = '{"user": "U-123", "password": "mySecret123", "card_number": "4111111111111111"}'
safe_entry = sanitize_log(log_entry)
# → {"user": "U-123", "password": "***REDACTED***", "card_number": "***REDACTED***"}
```

```java
// Java - Logback 커스텀 레이아웃으로 마스킹
public class MaskingPatternLayout extends PatternLayout {
    private Pattern multilinePattern;
    private List<String> maskPatterns = new ArrayList<>();

    public void addMaskPattern(String pattern) {
        maskPatterns.add(pattern);
        multilinePattern = Pattern.compile(
            String.join("|", maskPatterns), Pattern.MULTILINE
        );
    }

    @Override
    public String doLayout(ILoggingEvent event) {
        String message = super.doLayout(event);
        if (multilinePattern == null) return message;
        
        Matcher matcher = multilinePattern.matcher(message);
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            matcher.appendReplacement(sb, "***REDACTED***");
        }
        matcher.appendTail(sb);
        return sb.toString();
    }
}
```

---

## 9. 사고 대응 타임라인과 로그

실제 보안 사고에서 로그가 어떻게 사용되는지:

```
━━━ 사고 발생 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Day 0 (탐지):
  │ SIEM 알림: "비정상 대량 데이터 조회 감지"
  │ └─ 접근 로그에서 새벽 3시 DB 대량 조회 확인
  │
  Day 1 (초기 분석):
  │ 인증 로그 분석: 
  │ └─ 침입에 사용된 계정 식별 (ADMIN-042)
  │ └─ 로그인 IP: 해외 (일반적이지 않은 위치)
  │ └─ MFA 우회 확인 → 세션 하이재킹으로 판단
  │
  Day 2-3 (범위 규정):
  │ 감사 로그 분석:
  │ └─ ADMIN-042 계정으로 수행된 모든 작업 추적
  │ └─ 접근한 데이터 목록 확정
  │ └─ 변경/삭제된 데이터 식별
  │ 네트워크 로그 분석:
  │ └─ C2 서버 IP 식별
  │ └─ 유출된 데이터 크기 추정
  │
  Day 3-7 (근본 원인 분석):
  │ 애플리케이션 로그 역추적:
  │ └─ 최초 침입 시점을 3개월 전으로 특정 (← 보존 기간이 3개월 이상이어야 가능!)
  │ └─ 피싱 이메일을 통한 초기 진입 확인
  │ └─ 활성 디렉토리 로그에서 lateral movement 경로 파악
  │
  Day 7+ (보고·개선):
  │ 타임라인 보고서 작성
  │ └─ 모든 증거는 로그에서 추출
  │ └─ 규제 기관 신고 (개인정보 유출 시 72시간 이내)
  │ └─ 재발 방지 대책 수립

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 정리

```
보안 로그 보존:
│
├── 왜? 평균 204일의 체류 시간 → 30일 보존으로는 공격 추적 불가
│
├── 표준:
│   ├── NIST SP 800-92: 로그 관리 생명주기 (생성→전송→저장→분석→폐기)
│   ├── NIST SP 800-53 AU: 10개 감사 제어 항목
│   └── OWASP: What to log / What NOT to log
│
├── 보존 기간:
│   ├── 국내: PIPA 1~2년, 전자금융거래법 5년
│   ├── 해외: PCI DSS 1년, HIPAA 6년, SOX 7년
│   └── 원칙: 적용되는 규정 중 가장 긴 기간
│
├── 티어드 스토리지:
│   ├── Hot (0~30일): 실시간, ES/Splunk ($$$)
│   ├── Warm (31~180일): 검색 가능, S3 ($$)
│   └── Cold (181일+): 아카이브, Glacier ($)
│   └── 약 81% 비용 절감
│
├── 로그 보호 5계층:
│   ├── ① 원본 분리 (앱서버 ≠ 로그서버)
│   ├── ② 접근 제어 (최소 권한, 역할 분리)
│   ├── ③ 전송 보호 (TLS, mTLS)
│   ├── ④ 변조 탐지 (해시 체인, Merkle 트리)
│   └── ⑤ 삭제 방지 (WORM 스토리지)
│
├── 포렌식 준비:
│   ├── 진정성·무결성·신뢰성·관리연속성 4요건
│   └── NTP 동기화 필수 (인과관계 보장)
│
└── 민감 정보: 절대 로그에 넣지 말고, 마스킹 자동화
```
