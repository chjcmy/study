# 동기 vs 비동기 개념

---

## 핵심 구분: 4가지 조합

```
             블로킹 (기다림)                논블로킹 (안 기다림)
         ┌─────────────────────┐       ┌─────────────────────┐
동기     │  Sync + Blocking    │       │  Sync + Non-Blocking│
(직접    │  read() 끝날 때까지  │       │  계속 확인하기       │
 확인)   │  구 멈춤. 가장 단순  │       │  (busy waiting)     │
         │  예: requests.get() │       │  예: poll/select     │
         └─────────────────────┘       └─────────────────────┘

         ┌─────────────────────┐       ┌─────────────────────┐
비동기   │  (실제 구현이        │       │  Async + Non-Block  │
(OS/     │   의미 없음)         │       │  콜백/await으로      │
 콜백    │                     │       │  통보 받음 ⭐         │
 알림)   │                     │       │  예: asyncio, epoll  │
         └─────────────────────┘       └─────────────────────┘
```

### 각 조합 상세

```
Sync + Blocking (가장 흔한 기본 방식):
  "커피 나올 때까지 카운터 앞에서 서 있기"
  → 직관적, 구현 간단
  → 다른 일 못 함 → 비효율적
  → 예: Python requests, Java JDBC
  
Sync + Non-Blocking (폴링):
  "진동벨 없이 계속 '됐나요?' 물어보기"
  → CPU가 계속 확인 (busy waiting) → 낭비
  → 예: O_NONBLOCK 소켓, spinlock
  
Async + Non-Blocking (가장 효율적):
  "진동벨 받고 자리에서 다른 일 하다가 벨 울리면 가기"
  → I/O 대기 중 다른 작업 가능 → 최고 효율
  → 예: asyncio, Node.js, epoll + callback
```

---

## 실생활 비유

```
커피숍 비유:

Sync + Blocking:
  │ 주문 │ ....대기.... │ 커피 받음 │
  카운터 앞에서 멀뚱멀뚱

Sync + Non-Blocking:
  │ 주문 │ 됐나? │ 됐나? │ 됐나? │ 됐나? │ 커피 받음 │
  매번 물어보러 감 (CPU 낭비!)

Async + Non-Blocking:
  │ 주문 + 번호표 │ 다른 일 │ 다른 일 │ 벨! │ 커피 받음 │
  대기 중 다른 일 가능 ⭐

식당 비유 (서버 관점):
  동기 웹서버 (1요청=1스레드):
    웨이터 1명 = 손님 1명만 서빙
    100명 → 웨이터 100명 필요!

  비동기 웹서버 (이벤트 루프):
    웨이터 1명이 여러 테이블 담당
    주문 받고 → 주방에 넘기고 → 다른 테이블로
    음식 나오면 → 해당 테이블에 서빙
```

---

## 왜 비동기가 중요한가?

### 동기 서버의 한계

```
동기 서버 (1 요청 = 1 스레드):

시간 →
Thread-1: [요청A 처리][───DB 대기───][응답A]
Thread-2: [요청B 처리][───API 대기───][응답B]
Thread-3: [요청C 처리][───DB 대기───][응답C]
...
Thread-100: 더 이상 스레드 생성 불가! → Connection Refused

문제:
  - 스레드 = 메모리 (각 수 MB) → 수천 개 = 수 GB
  - 컨텍스트 스위칭 비용
  - I/O 대기 중 스레드가 놀고 있음
```

### 비동기 서버의 효율

```
비동기 서버 (이벤트 루프, 1 스레드):

시간 →
이벤트 루프: [요청A][요청B][요청C][B완료][A완료][C완료]
              │      │      │
              └─ DB에 맡김   └─ API에 맡김
                대기 없이 다음 요청 처리!

장점:
  - 1 스레드로 수천~수만 동시 연결
  - 메모리 효율 (코루틴 = 수 KB)
  - 컨텍스트 스위칭 최소
  
Log-Doctor:
  FastAPI + asyncio → 동시 수백 요청 처리 가능
```

---

## 면접 핵심 포인트

```
Q: 동기와 비동기의 차이?
A: 동기는 "직접 결과를 확인", 비동기는 "결과를 통보받음".
   동기 + 블로킹: 결과 나올 때까지 대기
   비동기 + 논블로킹: I/O를 OS에 맡기고 다른 일 수행

Q: 비동기가 멀티스레드보다 효율적인 이유?
A: 스레드는 생성 비용(MB) + 전환 비용 + 동기화 문제.
   코루틴은 가벼움(KB) + 전환 비용 최소 + 동기화 불필요.
   I/O 바운드에서 1 스레드로 수만 동시 처리 가능.

Q: 모든 것을 비동기로 만들면 되나?
A: CPU 바운드 작업은 비동기로 해결 불가.
   → 이벤트 루프를 블로킹하면 모든 요청이 멈춤!
   → CPU 바운드는 멀티프로세싱 또는 스레드 풀 사용.
```
