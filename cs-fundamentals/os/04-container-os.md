# 컨테이너와 OS

---

## VM vs 컨테이너

### 가상머신 (Virtual Machine)

```
물리 서버
┌─────────────────────────────────────────┐
│  하드웨어 (CPU, RAM, 디스크)              │
├─────────────────────────────────────────┤
│  Host OS (Linux/Windows)                 │
├─────────────────────────────────────────┤
│  Hypervisor (VMware, Hyper-V, KVM)       │
├──────────┬──────────┬──────────┤
│ VM 1     │ VM 2     │ VM 3     │
│ Guest OS │ Guest OS │ Guest OS │  ← 각각 전체 OS!
│ 라이브러리│ 라이브러리│ 라이브러리│
│ 앱 A     │ 앱 B     │ 앱 C     │
└──────────┴──────────┴──────────┘

특징:
  - 완전한 OS 격리 (커널부터 독립)
  - 무거움 (GB 단위, 부팅 분 단위)
  - 오버헤드 있음 (하이퍼바이저)
  - 다른 OS 실행 가능 (Linux 위에 Windows)
```

### 컨테이너 (Docker)

```
물리 서버
┌─────────────────────────────────────────┐
│  하드웨어 (CPU, RAM, 디스크)              │
├─────────────────────────────────────────┤
│  Host OS (Linux 커널)                    │  ← 커널 공유!
├─────────────────────────────────────────┤
│  Container Runtime (Docker Engine)       │
├──────────┬──────────┬──────────┤
│ 컨테이너1 │ 컨테이너2 │ 컨테이너3 │
│ (라이브러리)│ (라이브러리)│ (라이브러리)│  ← OS 없이 라이브러리만!
│ 앱 A     │ 앱 B     │ 앱 C     │
└──────────┴──────────┴──────────┘

특징:
  - 프로세스 수준 격리 (커널 공유)
  - 가벼움 (MB 단위, 시작 초 단위)
  - 오버헤드 거의 없음 (네이티브 성능)
  - 같은 OS에서만 (Linux 위에 Linux)
```

### 비교 표

| 구분 | VM | 컨테이너 |
|------|-----|---------|
| 격리 수준 | 커널 레벨 (완전) | 프로세스 레벨 |
| 크기 | GB 단위 | MB 단위 |
| 시작 시간 | 분 | **초** |
| 성능 | 하이퍼바이저 오버헤드 | **네이티브에 가까움** |
| OS | 다른 OS 가능 | 호스트 OS 커널 공유 |
| 밀도 | 서버당 수십 개 | 서버당 **수백~수천 개** |
| 보안 | 강력 (커널 격리) | 비교적 약함 (커널 공유) |
| 사용처 | 레거시, 다른 OS 필요 | **MSA, CI/CD, 클라우드** |

---

## Linux 컨테이너 핵심 기술

### Namespace (격리)

```
Namespace = 프로세스가 볼 수 있는 범위를 격리

┌──────────────────────────────────────────┐
│ PID Namespace                             │
│   호스트: PID 1 (init) → 100, 101, 102... │
│   컨테이너A: PID 1 (앱) → 2, 3...        │  ← 컨테이너 안에서는 자기가 PID 1!
│   컨테이너B: PID 1 (앱) → 2, 3...        │
├──────────────────────────────────────────┤
│ NET Namespace                             │
│   각 컨테이너마다 독립된 네트워크 스택      │
│   컨테이너A: eth0 (172.17.0.2)            │
│   컨테이너B: eth0 (172.17.0.3)            │
├──────────────────────────────────────────┤
│ MNT Namespace                             │
│   각 컨테이너마다 독립된 파일시스템          │
│   컨테이너A: / → 앱A의 파일들만 보임       │
│   컨테이너B: / → 앱B의 파일들만 보임       │
├──────────────────────────────────────────┤
│ 기타: UTS (호스트명), IPC (프로세스간통신), │
│       User (사용자 ID), Cgroup             │
└──────────────────────────────────────────┘
```

### cgroups (리소스 제한)

```
cgroups = 프로세스 그룹의 리소스 사용량 제한

CPU 제한:
  컨테이너A: CPU 최대 0.5 코어 (50%)
  컨테이너B: CPU 최대 2.0 코어

메모리 제한:
  컨테이너A: 최대 512MB (초과 시 OOM Kill!)
  컨테이너B: 최대 2GB

I/O 제한:
  디스크 읽기/쓰기 대역폭 제한

네트워크:
  대역폭 제한 가능
```

### Union File System (레이어 시스템)

```
Docker 이미지 = 읽기 전용 레이어의 스택

Layer 4 (R/W): 컨테이너 실행 중 변경사항  ← 쓰기 가능
─────────────
Layer 3 (R/O): COPY . /app               ← 앱 코드
Layer 2 (R/O): RUN pip install ...        ← 의존성
Layer 1 (R/O): FROM python:3.11           ← 베이스 이미지

장점:
  - 같은 레이어를 여러 컨테이너가 공유 (디스크 절약)
  - 변경된 레이어만 전송 (빌드/배포 빠름)
  - Copy-on-Write: 수정 시에만 새 레이어에 복사
```

---

## Container App 스케일링과 OS

```
Container App이 Replica를 늘릴 때:

Replica 1 (컨테이너)  ← 같은 이미지, PID Namespace 격리
Replica 2 (컨테이너)  ← 독립 메모리, cgroups로 리소스 제한
Replica 3 (컨테이너)  ← NET Namespace 격리, 로드밸런서 분배

각 Replica는 OS 관점에서:
  1. 독립된 프로세스 그룹 (Namespace 격리)
  2. 리소스 제한 (cgroups)
  3. 파일시스템 격리 (Union FS)
  4. 네트워크 격리 (veth + bridge)

스케일링 규칙 예시:
  HTTP 동시 요청 > 50 → Replica 추가
  CPU 사용률 > 70% → Replica 추가
  최소 1개, 최대 10개
```

---

## 면접 핵심 포인트

```
Q: Docker 컨테이너의 격리 원리?
A: Linux Namespace(PID/NET/MNT 등으로 가시성 격리)와
   cgroups(CPU/메모리 리소스 제한)로 프로세스 수준 격리.
   VM과 달리 커널을 공유하므로 가볍지만 격리 수준은 낮음.

Q: VM과 컨테이너의 차이점?
A: VM은 하이퍼바이저 위에 전체 OS(커널 격리), GB 단위.
   컨테이너는 호스트 커널 공유(프로세스 격리), MB 단위.
   성능/밀도는 컨테이너 우세, 보안 격리는 VM 우세.

Q: Docker 이미지의 레이어 구조?
A: Union File System으로 읽기 전용 레이어를 스택.
   같은 베이스를 여러 이미지가 공유(디스크 절약).
   컨테이너 실행 시 최상단에 쓰기 가능 레이어 추가.
```
