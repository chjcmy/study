# 세그먼트 트리 (Segment Tree)

## 1. 개요
배열의 **특정 구간 합(Range Sum)**, 구간 최솟값/최댓값 등을 빠르게 구하기 위해 사용되는 이진 트리입니다.
데이터 변경이 빈번할 때, 단순 배열보다 효율적입니다.

## 2. 시간 복잡도
- **구간 합 구하기**: $O(\log N)$
- **데이터 업데이트**: $O(\log N)$
- (단순 배열 사용 시: 구간 합 $O(N)$, 업데이트 $O(1)$ 혹은 구간 합 $O(1)$(Prefix Sum), 업데이트 $O(N)$)

## 3. 파이썬 구현 (구간 합)

```python
# 보통 배열 크기의 4배 정도를 트리 배열 크기로 잡음
import sys

# 1. 트리 초기화 (init)
def init(start, end, index):
    if start == end:
        tree[index] = arr[start]
        return tree[index]
    mid = (start + end) // 2
    tree[index] = init(start, mid, index * 2) + init(mid + 1, end, index * 2 + 1)
    return tree[index]

# 2. 구간 합 구하기 (query)
# [left, right]: 구하고자 하는 구간
# [start, end]: 현재 노드가 담당하는 구간
def query(start, end, index, left, right):
    if left > end or right < start: # 범위 밖
        return 0
    if left <= start and end <= right: # 범위 
        return tree[index]
    mid = (start + end) // 2
    return query(start, mid, index * 2, left, right) + query(mid + 1, end, index * 2 + 1, left, right)

# 3. 데이터 갱신 (update)
def update(start, end, index, what, diff):
    if what < start or what > end: # 범위 밖
        return
    tree[index] += diff
    if start == end:
        return
    mid = (start + end) // 2
    update(start, mid, index * 2, what, diff)
    update(mid + 1, end, index * 2 + 1, what, diff)

# 사용 예시
arr = [1, 2, 3, 4, 5]
tree = [0] * (len(arr) * 4)

init(0, len(arr) - 1, 1)
print(f"구간 합 (0~2): {query(0, len(arr)-1, 1, 0, 2)}") # 1+2+3 = 6

# 인덱스 2의 값을 +3 변경 (3 -> 6)
diff = 3
update(0, len(arr)-1, 1, 2, diff)
print(f"갱신 후 구간 합 (0~2): {query(0, len(arr)-1, 1, 0, 2)}") # 1+2+6 = 9
```