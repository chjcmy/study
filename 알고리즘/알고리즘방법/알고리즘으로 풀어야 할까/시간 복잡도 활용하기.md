# 시간 복잡도 활용하기 (Time Complexity)

## 1. 개요
코딩 테스트에서 문제는 보통 **제한 시간(Time Limit)** 이 주어집니다. (보통 1초 ~ 5초)
파이썬(Python)의 경우 **1초에 약 2,000만 ~ 1억 번의 연산**을 수행할 수 있다고 가정하면 좋습니다.
입력 데이터의 크기(N)를 보고 사용할 수 있는 알고리즘의 시간 복잡도를 유추해야 합니다.

## 2. N의 크기에 따른 추천 알고리즘

| N의 범위 | 허용 시간 복잡도 | 추천 알고리즘 |
| :--- | :--- | :--- |
| **N $\le$ 500** | $O(N^3)$ | 플로이드-워셜, 3중 반복문 |
| **N $\le$ 2,000** | $O(N^2)$ | 버블/선택/삽입 정렬, 2중 반복문 |
| **N $\le$ 100,000** | $O(N \log N)$ | 병합/퀵/힙 정렬, 이진 탐색(여러 번 수행) |
| **N $\le$ 1,000,000** | $O(N)$ | 해시($O(1)$), 투 포인터, 그리디, DP, 슬라이딩 윈도우 |
| **N $\ge$ 1억** | $O(\log N)$, $O(1)$ | 이진 탐색(단일 수행), 수학적 공식 |

## 3. 시간 복잡도 표기법 (Big-O)

- **$O(1)$ (상수 시간)**: 입력 크기에 상관없이 바로 결과 도출 (Pop/Append, 해시)
- **$O(\log N)$ (로그 시간)**: 단계마다 입력이 절반으로 줄어듦 (이진 탐색)
- **$O(N)$ (선형 시간)**: 입력 크기만큼 반복 (for문 1번)
- **$O(N \log N)$**: 효율적인 정렬 알고리즘 (Sort)
- **$O(N^2)$ (이차 시간)**: 이중 반복문 (완전 탐색)
- **$O(2^N)$ (지수 시간)**: 재귀적 완전 탐색 (N이 아주 작을 때만 가능)

## 4. 파이썬 성능 팁
파이썬은 인터프리터 언어라 느릴 수 있으므로, 입출력 속도를 높이는 것이 중요합니다.

```python
import sys

# 1. 빠른 입력 (필수)
input = sys.stdin.readline

# 예시: 정수 한 개 입력
n = int(input())

# 예시: 공백 구분 리스트 입력
arr = list(map(int, input().split()))

# 2. PyPy3 사용 고려
# 일반적인 알고리즘(반복문 위주, DP, 탐색)은 PyPy3가 Python3보다 훨씬 빠릅니다.
# 단, 메모리 제한이 타이트하거나 시스템 함수 사용 시 Python3가 유리할 때도 있습니다.
```
