# 기수 정렬 (Radix Sort)

## 1. 개요
데이터를 비교하지 않고, 데이터의 **자릿수**를 기준으로 버킷(Bucket)에 나누어 담았다가 합치는 과정을 반복하여 정렬하는 방식입니다. 정수나 문자열처럼 자릿수가 명확한 데이터에만 사용할 수 있습니다.

## 2. 동작 과정 (LSD: Least Significant Digit 기준)
1. 1의 자릿수(가장 낮은 자릿수)를 기준으로 데이터를 0~9번 버킷에 분류합니다.
2. 버킷 순서대로 데이터를 다시 가져와 나열합니다.
3. 10의 자릿수, 100의 자릿수 등 가장 높은 자릿수까지 반복합니다.
4. 모든 자릿수에 대해 처리가 끝나면 정렬이 완료됩니다.

## 3. 시간 복잡도
- **O(dN)** (d: 최대 자릿수, N: 데이터 개수)
- 비교 정렬(Comparison Sort)의 하한선인 O(n log n)을 깰 수 있는 알고리즘입니다.

## 4. 장단점
- **장점**: 매우 빠릅니다. (자릿수가 작을 경우)
- **단점**: 자릿수가 없는 데이터(부동 소수점 등)에는 적용하기 어렵습니다. 추가적인 메모리 공간(버킷)이 필요합니다.

## 5. 파이썬(Python) 구현 코드

```python
from collections import deque

def radix_sort(arr):
    # 가장 큰 수의 자릿수(최대 자릿수) 구하기
    max_val = max(arr)
    max_digit = len(str(max_val))
    
    # 0~9까지의 버킷 생성 (큐 사용)
    buckets = [deque() for _ in range(10)]
    
    digit_position = 1 # 1의 자리부터 시작
    
    for i in range(max_digit):
        # 각 데이터를 자릿수에 맞는 버킷에 넣기
        for num in arr:
            digit = (num // digit_position) % 10
            buckets[digit].append(num)
        
        # 버킷에서 순서대로 꺼내서 arr 재구성
        index = 0
        for bucket in buckets:
            while bucket:
                arr[index] = bucket.popleft()
                index += 1
                
        digit_position *= 10 # 다음 자릿수로 이동 (1 -> 10 -> 100 ...)
        
    return arr

# 사용 예시
data = [170, 45, 75, 90, 802, 24, 2, 66]
print(f"정렬 전: {data}")
sorted_data = radix_sort(data)
print(f"정렬 후: {sorted_data}")
```
