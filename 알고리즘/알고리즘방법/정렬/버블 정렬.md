# 버블 정렬 (Bubble Sort)

## 1. 개요
데이터의 **인접한 두 원소**를 비교하여, 정렬 조건(오름차순/내림차순)에 맞지 않으면 서로 교환(Swap)하는 방식입니다.
한 번의 회전(Pass)이 끝날 때마다 가장 큰(또는 가장 작은) 요소가 맨 뒤로 이동하여 자리를 잡는 모습이 마치 거품이 수면 위로 올라오는 것과 같다고 하여 버블 정렬이라 부릅니다.

## 2. 동작 과정 (오름차순 기준)
1. 첫 번째 원소와 두 번째 원소를 비교합니다.
2. 앞 원소가 뒤 원소보다 크다면 위치를 바꿉니다. (Swap)
3. 두 번째와 세 번째, ..., (n-1)번째와 n번째 원소를 비교하며 끝까지 진행합니다.
4. 1회전이 끝나면 가장 큰 원소가 맨 뒤에 고정됩니다.
5. 다음 회전에서는 맨 뒤에 고정된 원소를 제외하고 나머지 원소들에 대해 반복합니다.

## 3. 시간 복잡도
- **최악의 경우**: O(n²) (역순으로 정렬된 경우)
- **최선의 경우**: O(n²) (이미 정렬되어 있어도 비교는 계속함. 단, 최적화된 코드는 O(n) 가능)
- **평균**: O(n²)

## 4. 장단점
- **장점**: 구현이 매우 간단하고 직관적입니다. 제자리 정렬(In-place Sort)로 추가 메모리가 거의 필요 없습니다.
- **단점**: 시간 복잡도가 O(n²)로 비효율적입니다. 데이터의 개수가 많아질수록 성능이 급격히 저하됩니다.

## 5. 파이썬(Python) 구현 코드

```python
def bubble_sort(arr):
    n = len(arr)
    # n개의 요소에 대해 n-1번의 회전이 필요
    for i in range(n):
        # 이미 정렬된 뒷부분을 제외하고 비교 (n-1-i)
        for j in range(n - 1 - i):
            # 인접한 두 요소를 비교
            if arr[j] > arr[j + 1]:
                # Swap
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 사용 예시
data = [64, 34, 25, 12, 22, 11, 90]
print(f"정렬 전: {data}")
sorted_data = bubble_sort(data)
print(f"정렬 후: {sorted_data}")
```