# 퀵 정렬 (Quick Sort)

## 1. 개요
**기준값(Pivot)** 을 설정하고 그 기준보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽으로 비균등하게 분할(Partitioning)한 후, 각각 재귀적으로 정렬하는 방식입니다.

## 2. 동작 과정
1. 리스트에서 하나의 원소를 골라 **Pivot**으로 설정합니다.
2. Pivot 앞에는 Pivot보다 값이 작은 모든 원소들이 오고, Pivot 뒤에는 Pivot보다 값이 큰 모든 원소들이 오도록 리스트를 둘로 나눕니다. (분할)
3. 분할된 두 개의 작은 리스트에 대해 재귀적으로 이 과정을 반복합니다.
4. 재귀 호출이 멈추는 시점(리스트의 크기가 0이나 1)이 되면 정렬이 완료됩니다.

## 3. 시간 복잡도
- **평균**: **O(n log n)**
- **최악**: O(n²) (이미 정렬되어 있는데 Pivot을 계속 최솟값/최댓값으로 잡는 경우)

## 4. 장단점
- **장점**: 평균적으로 매우 빠른 수행 속도를 보입니다. 추가 메모리 공간을 거의 사용하지 않습니다.
- **단점**: Pivot 선정에 따라 성능 차이가 큽니다. 불안정 정렬입니다.

## 5. 파이썬(Python) 구현 코드

```python
def quick_sort(arr):
    # 리스트가 하나 이하의 원소를 가지면 종료
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]  # 가운데 요소를 피벗으로 선택
    lesser_arr, equal_arr, greater_arr = [], [], []
    
    for num in arr:
        if num < pivot:
            lesser_arr.append(num)
        elif num > pivot:
            greater_arr.append(num)
        else:
            equal_arr.append(num)
            
    # 재귀 호출로 정렬 후 병합
    return quick_sort(lesser_arr) + equal_arr + quick_sort(greater_arr)

# 사용 예시
data = [6, 5, 1, 4, 7, 2, 3]
print(f"정렬 전: {data}")
sorted_data = quick_sort(data)
print(f"정렬 후: {sorted_data}")
```