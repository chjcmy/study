# 라그랑주 네 제곱수 정리 (Lagrange's Four-Square Theorem)

## 1. 개요
**라그랑주 네 제곱수 정리**는 **모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다**는 정리입니다.
$$ n = a^2 + b^2 + c^2 + d^2 $$
(단, $a, b, c, d$는 0 이상의 정수)

## 2. 알고리즘 문제에서의 활용 (DP)
이 정리는 "자연수 N을 최소 몇 개의 제곱수 합으로 표현할 수 있는가?" (예: 백준 17626 Four Squares)와 같은 문제에서 **최대 답이 4**임을 보장해 줍니다.
따라서 답은 1, 2, 3, 4 중 하나가 됩니다.

## 3. DP를 이용한 풀이
어떤 수 $i$를 제곱수의 합으로 표현할 때, 마지막에 더해진 제곱수를 $j^2$라고 하면,
나머지 값 $i - j^2$ 또한 최소 개수의 제곱수 합으로 표현되어야 합니다.

**점화식:**
$$ DP[i] = \min(DP[i - j^2]) + 1 $$
(단, $j^2 \le i$)

## 4. 파이썬 구현

```python
import math

def solve_four_squares(n):
    # DP 테이블 초기화 (최악의 경우인 1^2의 합으로 채움)
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = i # 초기값: 1^2 + 1^2 ... (개수 i개)
        
        # 1부터 제곱근까지 반복하며 최소 횟수 갱신
        for j in range(1, int(math.sqrt(i)) + 1):
            dp[i] = min(dp[i], dp[i - j*j] + 1)
            
    return dp[n]

# 더 최적화된 방법 (브루트포스 + 이론 기반)
def solve_optimized(n):
    # 1. 답이 1인 경우 (n이 제곱수)
    if int(n**0.5)**2 == n:
        return 1
        
    # 2. 답이 2인 경우 (n = a^2 + b^2)
    # 브루트포스로 확인 (하나를 빼서 제곱수인지)
    for i in range(1, int(n**0.5) + 1):
        if int((n - i**2)**0.5)**2 == (n - i**2):
            return 2
            
    # 3. 답이 3인 경우 (르장드르 정리에 의해 제외 가능하지만 여기선 생략)
    # 4. 르장드르 세 제곱수 정리에 의해 3이 아닌 경우 4 (n = 4^a(8b + 7) 꼴일때 4)
    # 일반적인 DP로는 위 함수 사용.
    pass

n = 25 # 5^2 (답: 1)
print(f"25의 최소 제곱수 개수: {solve_four_squares(25)}")
n = 26 # 5^2 + 1^2 (답: 2)
print(f"26의 최소 제곱수 개수: {solve_four_squares(26)}")
```

> [!TIP] 관련 알고리즘
> - [동적 계획법](../동적%20계획법.md)
> - [르장드르의 세 제곱수 정리](르장드르의%20세%20제곱수%20정리.md)
