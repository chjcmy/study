# 슬라이딩 윈도우 (Sliding Window)

## 1. 개요
배열이나 리스트의 **일정 범위(Window)** 를 결정하고, 그 윈도우를 **한 칸씩 이동(Sliding)** 시키면서 범위 내의 데이터를 처리하는 알고리즘입니다.
이중 반복문(O(n²))을 사용해야 할 문제를 **단일 반복문(O(n))** 으로 해결할 수 있게 해줍니다.

## 2. 동작 과정
1. 윈도우의 크기(k)를 결정합니다.
2. 초기 윈도우(인덱스 0부터 k-1)의 값을 계산합니다.
3. 윈도우를 한 칸씩 오른쪽으로 이동합니다.
    - 이동할 때, **윈도우에서 빠지는 값**은 빼고 **새로 들어오는 값**은 더합니다.
    - 이렇게 하면 매번 전체 합을 다시 계산할 필요 없이, O(1) 연산으로 윈도우 상태를 갱신할 수 있습니다.
4. 배열의 끝까지 이동하며 필요한 계산(최대/최소 합, 평균 등)을 수행합니다.

## 3. 시간 복잡도
- **O(n)**: 배열을 한 번만 순회하면 되므로 효율적입니다.

## 4. 장단점
- **장점**: 반복적인 연산을 줄여 효율성을 극대화할 수 있습니다.
- **단점**: 윈도우 크기가 고정적이어야 주로 사용하기 쉽습니다. (가변 윈도우는 투 포인터와 유사함)

## 5. 파이썬(Python) 구현 코드

```python
def max_sliding_window_sum(arr, k):
    n = len(arr)
    if n < k:
        return -1
    
    # 1. 초기 윈도우의 합 계산
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # 2. 윈도우를 한 칸씩 이동하며 갱신
    for i in range(n - k):
        # i번째 요소는 빠지고, (i+k)번째 요소는 들어옴
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)
        
    return max_sum

# 사용 예시
data = [1, 2, 3, 4, 2, 5, 1]
k = 3
result = max_sliding_window_sum(data, k)
print(f"길이 {k}인 연속 부분 수열의 최대 합: {result}")
# (3+4+2 = 9), (4+2+5 = 11) -> 11
```