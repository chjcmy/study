# 테이블과 인덱스 분리
#Database/Architecture #Database/Performance

> [!INFO] 테이블과 인덱스 분리란?
> 대용량 데이터베이스 환경에서 성능을 최적화하고 관리의 효율성을 높이기 위해, **테이블(실제 데이터)과 인덱스를 서로 다른 물리적 저장 공간(테이블스페이스, 파일그룹 등)에 분리하여 저장**하는 데이터베이스 설계 기법입니다.

## 왜 분리하는가? (장점)

1.  **I/O 성능 향상**
    -   **디스크 경합 감소**: 테이블을 읽는 I/O 작업과 인덱스를 탐색하는 I/O 작업을 서로 다른 디스크에서 동시에 처리할 수 있습니다. 이를 통해 디스크 헤드의 움직임을 최소화하고 I/O 병목 현상을 줄여 전체적인 쿼리 처리 속도를 개선합니다.
    -   **접근 패턴 최적화**: 테이블 데이터는 주로 순차적 접근(Sequential Access)이, 인덱스는 무작위 접근(Random Access)이 많이 발생합니다. 각 접근 패턴에 최적화된 디스크(예: 데이터는 HDD, 인덱스는 SSD)에 분산 배치하여 성능을 극대화할 수 있습니다.

2.  **유연한 스토리지 관리**
    -   데이터와 인덱스의 증가 추세나 중요도에 따라 독립적인 스토리지 정책(용량 증설, 백업 주기 등)을 적용할 수 있습니다.

3.  **백업 및 복구 최적화**
    -   데이터와 인덱스를 독립적으로 백업하고 복구할 수 있어, 장애 발생 시 복구 시간을 단축할 수 있습니다. 최악의 경우 인덱스 파일이 손상되더라도, 데이터 파일만으로 복구한 뒤 인덱스를 재생성(`REBUILD`)하는 전략을 사용할 수 있습니다.

## 단점

1.  **관리 복잡성 증가**: 여러 개의 테이블스페이스나 파일그룹을 관리해야 하므로 설계 및 운영의 복잡성이 증가합니다.
2.  **필수적인 기법은 아님**: 최신 고성능 스토리지(NVMe SSD 등) 환경에서는 디스크 I/O가 더 이상 주요 병목 지점이 아닐 수 있습니다. 따라서 모든 환경에서 이 기법이 항상 성능 향상을 보장하는 것은 아닙니다.

## 구현 방법 (예시)

> [!NOTE]
> 데이터베이스 시스템마다 구현 방법이 다릅니다. Oracle이나 PostgreSQL에서는 **테이블스페이스(Tablespace)**를, SQL Server에서는 **파일그룹(Filegroup)**을 사용합니다.

아래는 PostgreSQL/Oracle 환경에서의 예시입니다.

```sql
-- 1. 데이터와 인덱스를 저장할 별도의 테이블스페이스 생성
CREATE TABLESPACE data_ts LOCATION '/path/to/data';
CREATE TABLESPACE index_ts LOCATION '/path/to/index';

-- 2. 테이블은 data_ts에 생성
CREATE TABLE my_large_table (
    id INT PRIMARY KEY,
    content TEXT
)
TABLESPACE data_ts;

-- 3. 해당 테이블의 인덱스는 index_ts에 생성
CREATE INDEX idx_my_large_table_content ON my_large_table(content)
TABLESPACE index_ts;
```

> [!TIP] 언제 고려해야 할까?
> - 초당 트랜잭션 수(TPS)가 매우 높은 대용량 OLTP 시스템
> - 데이터베이스의 I/O 성능이 병목 현상의 주된 원인으로 분석될 때
> - 매우 큰 특정 테이블에 대한 I/O를 분산시키고 싶을 때

---
> [[00. 데이터베이스 목차.md|⬆️ 목차로 돌아가기]]