# SQL 고급 문법
#Database/SQL #SQL/Advanced

> [!INFO]
> 이 문서는 기본 SQL을 넘어, 복잡한 데이터 분석과 조작을 가능하게 하는 고급 SQL 기능들을 다룹니다. CTE, 윈도우 함수, 고급 조인 및 서브쿼리, 트랜잭션 제어 등을 포함합니다.

## 1. WITH 절 (Common Table Expression, CTE)

> [!NOTE] CTE
> 복잡한 쿼리를 논리적인 단위로 나누어 가독성을 높이고 재사용하기 위한 이름 있는 임시 결과 집합입니다.

-   **기본 구문**
    ```sql
    WITH high_performers AS (
        SELECT name, grade FROM students WHERE grade > 4.0
    )
    SELECT * FROM high_performers WHERE name LIKE '김%';
    ```
-   **재귀 CTE (Recursive CTE)**: 계층 구조 데이터를 쿼리할 때 사용합니다.
    ```sql
    WITH RECURSIVE employee_hierarchy AS (
        -- 1. 시작점 (Anchor Member)
        SELECT id, name, manager_id, 1 as level FROM employees WHERE manager_id IS NULL
        UNION ALL
        -- 2. 재귀 부분 (Recursive Member)
        SELECT e.id, e.name, e.manager_id, eh.level + 1
        FROM employees e
        INNER JOIN employee_hierarchy eh ON e.manager_id = eh.id
    )
    SELECT * FROM employee_hierarchy;
    ```

## 2. 윈도우 함수 (Window Functions)

> [!NOTE] Window Functions
> `GROUP BY`와 달리 행을 집계하지 않고, 각 행에 대해 순위, 누적 값, 비율 등을 계산하는 강력한 분석 함수입니다. `OVER()` 절과 함께 사용됩니다.

-   **순위 함수**: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`
    ```sql
    SELECT
        name,
        grade,
        RANK() OVER (ORDER BY grade DESC) as rank,
        DENSE_RANK() OVER (ORDER BY grade DESC) as dense_rank
    FROM students;
    ```
-   **분석 함수**: `LAG()` (이전 행), `LEAD()` (다음 행)
    ```sql
    SELECT
        date,
        value,
        LAG(value, 1, 0) OVER (ORDER BY date) as previous_value,
        LEAD(value, 1, 0) OVER (ORDER BY date) as next_value
    FROM time_series;
    ```
-   **`PARTITION BY`**: 그룹 내에서 윈도우 함수를 적용합니다.
    ```sql
    -- 각 부서(department) 내에서 급여 순위 매기기
    SELECT
        name,
        salary,
        department,
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank_in_dept
    FROM employees;
    ```

## 3. 고급 조인 (Advanced JOIN)

-   **`FULL OUTER JOIN`**: 양쪽 테이블의 모든 행을 반환하고, 일치하지 않는 부분은 `NULL`로 채웁니다. (MySQL은 `LEFT JOIN`과 `RIGHT JOIN`의 `UNION`으로 구현)
-   **`CROSS JOIN`**: 두 테이블의 모든 가능한 행의 조합(카테시안 곱)을 반환합니다.
-   **`SELF JOIN`**: 하나의 테이블을 자기 자신과 조인합니다. (예: 직원의 관리자 이름 찾기)
    ```sql
    SELECT e1.name as employee, e2.name as manager
    FROM employees e1
    LEFT JOIN employees e2 ON e1.manager_id = e2.id;
    ```

## 4. 고급 서브쿼리 (Advanced Subquery)

-   **상관 서브쿼리 (Correlated Subquery)**: 외부 쿼리의 컬럼을 참조하는 서브쿼리. 외부 쿼리의 각 행에 대해 서브쿼리가 반복 실행됩니다.
    ```sql
    -- 자신이 속한 부서의 평균 급여보다 많이 받는 직원 찾기
    SELECT name, salary FROM employees e1
    WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.department = e1.department);
    ```
-   **`EXISTS`**: 서브쿼리의 결과가 하나라도 존재하면 `TRUE`를 반환합니다.
    ```sql
    -- 한 번이라도 주문한 적이 있는 고객 찾기
    SELECT name FROM customers c
    WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
    ```

## 5. 고급 그룹화 (Advanced GROUP BY)

-   **`ROLLUP`**: `GROUP BY` 결과의 마지막에 각 그룹별 소계와 전체 총계를 추가로 보여줍니다.
    ```sql

    SELECT department, job_title, SUM(salary)
    FROM employees
    GROUP BY department, job_title WITH ROLLUP;
    ```

## 6. 트랜잭션 제어 (Transaction Control)

> [!NOTE] Transaction
> 더 이상 쪼갤 수 없는 작업의 논리적 단위. 모든 작업이 성공하거나(COMMIT), 모두 실패해야(ROLLBACK) 합니다.

-   **트랜잭션 시작과 종료**
    ```sql
    START TRANSACTION;
        -- SQL 문장들
    COMMIT; -- 모든 변경사항 영구 저장
    -- 또는
    ROLLBACK; -- 모든 변경사항 취소
    ```
-   **`SAVEPOINT`**: 트랜잭션 내에 중간 저장점을 만들어, 전체 롤백 대신 특정 지점으로만 되돌릴 수 있습니다.
    ```sql
    START TRANSACTION;
        INSERT INTO table1 VALUES (1, 'a');
        SAVEPOINT sp1;
        INSERT INTO table1 VALUES (2, 'b');
        ROLLBACK TO sp1; -- (2, 'b') 삽입만 취소됨
    COMMIT;
    ```
-   **격리 수준 설정 (Isolation Level)**
    ```sql
    SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    ```

---
> [[00. 데이터베이스 목차.md|⬆️ 목차로 돌아가기]]
> [[1. 기본.md|⬅️ 이전: 1. 기본]] | [[3. 심화.md|➡️ 다음: 3. 심화]]