# 데이터베이스 인덱스 (Index)
#Database/Index #Database/Performance

> [!INFO]
> 인덱스(Index)는 데이터베이스 테이블의 **검색 속도를 향상시키기 위한 자료 구조**입니다. 책의 맨 뒤에 있는 '찾아보기(색인)'처럼, 원하는 데이터를 빠르게 찾을 수 있도록 도와 시스템의 전반적인 성능을 개선하고 부하를 줄입니다.

## 작동 원리

1.  특정 컬럼(또는 여러 컬럼)의 값과 해당 값이 저장된 레코드의 물리적 위치(주소) 정보를 키-값 쌍으로 저장합니다.
2.  인덱스는 항상 **정렬된 상태**를 유지하므로, 데이터를 훨씬 빠르게 검색할 수 있습니다.
3.  이를 위해 내부적으로 B-트리(B-Tree)와 같은 균형 잡힌 트리 자료 구조를 주로 사용합니다.

## 장점과 단점

-   **장점**
    -   `WHERE` 절을 사용한 조건 검색 속도가 비약적으로 향상됩니다.
    -   `ORDER BY`를 사용한 정렬 작업의 효율성이 증가합니다.
    -   `JOIN` 연산의 성능을 개선합니다.

-   **단점**
    -   인덱스를 저장하기 위한 추가적인 디스크 공간이 필요합니다. (테이블 크기의 약 10% 내외)
    -   데이터 변경(`INSERT`, `UPDATE`, `DELETE`) 작업 시 인덱스도 함께 수정되어야 하므로 DML 성능 저하(오버헤드)가 발생합니다.
    -   따라서, 읽기 작업보다 쓰기 작업이 훨씬 더 빈번한 테이블에는 인덱스를 신중하게 적용해야 합니다.

## 인덱스 종류

1.  **단일 컬럼 인덱스**: 하나의 컬럼으로만 구성된 인덱스.
2.  **복합 컬럼 인덱스**: 두 개 이상의 컬럼을 조합하여 생성한 인덱스. `WHERE` 절에 해당 컬럼들이 함께 자주 사용될 때 효과적입니다.
3.  **고유 인덱스 (Unique Index)**: 인덱스 키에 중복된 값을 허용하지 않습니다. `PRIMARY KEY`나 `UNIQUE` 제약조건을 설정하면 자동으로 생성됩니다.
4.  **클러스터형 인덱스 (Clustered Index)**: 테이블의 데이터를 인덱스의 순서에 맞춰 물리적으로 정렬합니다. 테이블 당 하나만 존재할 수 있습니다.
5.  **비클러스터형 인덱스 (Non-Clustered Index)**: 데이터의 물리적 순서는 그대로 둔 채, 별도의 공간에 인덱스 페이지만 따로 만듭니다. 일반적인 인덱스는 대부분 이 방식입니다.

> [!TIP] 인덱스 생성 시 고려사항
> - **카디널리티(Cardinality)**가 높은 컬럼에 적용하는 것이 좋습니다. (즉, '성별'처럼 중복도가 높은 컬럼보다는 '이메일'처럼 고유한 값의 분포가 높은 컬럼이 인덱스에 적합합니다.)
> - `WHERE` 절에 자주 사용되는 컬럼을 우선적으로 고려합니다.
> - 데이터의 양이 적은 테이블은 인덱스보다 테이블 전체를 스캔하는 것이 더 빠를 수 있습니다.

## SQL 예시

```sql
-- 단일 컬럼 인덱스 생성
CREATE INDEX idx_lastname ON employees(last_name);

-- 복합 컬럼 인덱스 생성
CREATE INDEX idx_name ON employees(last_name, first_name);

-- 고유 인덱스 생성
CREATE UNIQUE INDEX idx_email ON employees(email);
```

## 성능 모니터링

-   **실행 계획 (Execution Plan)** 분석: `EXPLAIN` 명령어를 통해 쿼리가 인덱스를 효율적으로 사용하고 있는지(`Index Scan`) 확인할 수 있습니다.
-   주기적인 인덱스 재구성 및 최적화 작업이 필요할 수 있습니다.

---
> [[00. 데이터베이스 목차.md|⬆️ 목차로 돌아가기]]