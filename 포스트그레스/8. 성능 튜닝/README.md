# 8. 성능 튜닝 (Performance Tuning)
#PostgreSQL/Performance #PostgreSQL/Tuning

애플리케이션이 성장하고 데이터가 쌓이면, 초기에는 빨랐던 쿼리도 점점 느려지게 됩니다. PostgreSQL은 데이터베이스 관리자가 쿼리 성능을 분석하고 최적화할 수 있도록 강력한 도구와 메커니즘을 제공합니다. 이 단원에서는 성능 튜닝의 핵심적인 세 가지 요소인 `EXPLAIN`, `ANALYZE`, `VACUUM`에 대해 알아봅니다.

## 8.1. `EXPLAIN`: 쿼리 실행 계획 분석

> [!INFO]
> `EXPLAIN`은 PostgreSQL의 **쿼리 플래너(Query Planner)**가 특정 SQL 쿼리를 어떻게 실행할 것인지에 대한 '실행 계획'을 보여주는 명령어입니다. 이 계획을 통해 개발자는 쿼리의 어느 부분에서 비효율이 발생하는지 파악할 수 있습니다.

-   **실행 계획**: 쿼리를 처리하기 위한 단계별 절차. 예를 들어, 어떤 인덱스를 사용할지, 테이블을 어떤 순서로 조인할지 등을 결정합니다.
-   **비용(Cost)**: 실행 계획의 각 단계마다 예상되는 비용(디스크 I/O, CPU 사용량 등을 추상화한 값)을 보여줍니다. 비용이 높은 부분을 중심으로 튜닝을 진행해야 합니다.

```sql
-- 쿼리를 실행하지 않고 실행 계획만 확인
EXPLAIN SELECT * FROM employees WHERE name = 'Alice';
```

### `EXPLAIN ANALYZE`

`EXPLAIN`이 예상 계획을 보여준다면, `EXPLAIN ANALYZE`는 **실제로 쿼리를 실행하고** 그 결과를 바탕으로 실제 실행 시간과 비용을 함께 보여줍니다. 계획과 실제 실행 사이의 차이를 분석하는 데 매우 유용합니다.

```sql
-- 쿼리를 실제로 실행하고, 실제 실행 시간과 함께 실행 계획을 확인
EXPLAIN ANALYZE SELECT * FROM employees WHERE name = 'Alice';
```

> [!TIP] 실행 계획에서 확인할 것
> -   **`Seq Scan` vs `Index Scan`**: `Seq Scan`(Sequential Scan)은 테이블 전체를 스캔하는 것을 의미하며, 데이터가 많을 경우 비효율적입니다. `WHERE` 절의 조건이 인덱스를 잘 활용하여 `Index Scan`이나 `Bitmap Index Scan`으로 동작하는지 확인해야 합니다.
> -   **조인(Join) 방식**: `Nested Loop`, `Hash Join`, `Merge Join` 등 어떤 조인 방식이 사용되었는지, 그리고 조인 순서가 효율적인지 확인합니다.
> -   **예상 행 수 vs 실제 행 수**: 플래너가 예측한 행 수와 실제 반환된 행 수의 차이가 크다면, 통계 정보가 오래되었을 가능성이 높습니다. (아래 `ANALYZE` 참고)

## 8.2. `ANALYZE`: 통계 정보 갱신

> [!INFO]
> 쿼리 플래너는 테이블의 데이터 분포, 값의 종류, NULL 값의 비율 등 **통계 정보**를 바탕으로 최적의 실행 계획을 수립합니다. 만약 데이터가 대량으로 추가되거나 변경되었는데 통계 정보가 갱신되지 않았다면, 플래너는 비효율적인 실행 계획을 세울 수 있습니다.

`ANALYZE`는 테이블의 최신 상태를 분석하여 이 통계 정보를 갱신하는 명령어입니다.

```sql
-- 'employees' 테이블의 통계 정보를 갱신
ANALYZE employees;
```

일반적으로 `VACUUM` 명령어와 함께 사용되는 경우가 많습니다.

## 8.3. `VACUUM`: 불필요한 공간 회수 및 재사용

PostgreSQL은 MVCC 모델을 사용하기 때문에 `UPDATE`나 `DELETE`가 발생해도 이전 버전의 데이터(Dead Tuple)가 즉시 물리적으로 삭제되지 않습니다. 이 Dead Tuple들이 계속 쌓이면 다음과 같은 문제가 발생합니다.

-   **테이블 팽창(Bloat)**: 테이블의 물리적 크기가 불필요하게 커져 디스크 공간을 낭비하고, `Seq Scan` 시 더 많은 블록을 읽게 되어 성능이 저하됩니다.
-   **성능 저하**: 불필요한 데이터 조각들로 인해 인덱스의 효율도 떨어집니다.

`VACUUM`은 이러한 Dead Tuple들이 차지하는 공간을 회수하여 다시 사용할 수 있도록 만드는 필수적인 유지보수 작업입니다.

```sql
-- 'employees' 테이블을 VACUUM 처리 (ANALYZE도 함께 수행)
VACUUM ANALYZE employees;
```

-   **`VACUUM`**: Dead Tuple이 차지하던 공간을 '재사용 가능한 공간'으로 표시합니다. 테이블의 물리적 파일 크기를 줄이지는 않지만, 이후의 `INSERT`나 `UPDATE`가 이 공간을 재사용할 수 있게 합니다. 작업 중 테이블에 대한 일반적인 읽기/쓰기가 가능합니다.
-   **`VACUUM FULL`**: 테이블을 배타적으로 잠그고(Exclusive Lock), 테이블의 내용을 완전히 새로 써서 물리적인 파일 크기 자체를 줄입니다. 
    > [!WARNING] `VACUUM FULL`은 매우 느리고 시스템 부하가 크므로, 서비스 중에는 사용을 피해야 하며 꼭 필요한 경우에만 유지보수 시간을 통해 실행해야 합니다.

### `Autovacuum` 데몬

다행히 PostgreSQL에는 `autovacuum`이라는 백그라운드 프로세스가 있어, 테이블의 변경 사항(INSERT, UPDATE, DELETE)이 일정 수준에 도달하면 자동으로 `VACUUM`과 `ANALYZE`를 실행해 줍니다. 대부분의 경우 `autovacuum`이 데이터베이스를 최적의 상태로 유지해 주지만, 매우 큰 테이블이나 DML이 극단적으로 빈번한 테이블의 경우, `autovacuum` 관련 파라미터를 워크로드에 맞게 튜닝해야 할 수도 있습니다.

---
> [[00. 포스트그레스 목차|⬆️ 목차로 돌아가기]]
> [[7. 트랜잭션과 동시성/README|⬅️ 이전: 7. 트랜잭션과 동시성]] | [[9. 백업 및 복구/README|➡️ 다음: 9. 백업 및 복구]]