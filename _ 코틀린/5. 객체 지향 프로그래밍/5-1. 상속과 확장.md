---
tags: [Kotlin, 객체지향, 상속, 확장함수]
aliases: [Kotlin Inheritance vs Extension, 상속과 확장, 확장 함수]
---

# 상속과 확장 (Inheritance vs Extension)

> [!INFO]
> 코틀린에서 **상속(Inheritance)**과 **확장(Extension)**은 모두 기존 클래스의 기능을 재사용하고 새로운 기능을 추가하는 방법이지만, 근본적인 접근 방식과 사용 목적이 다릅니다.

## 1. 상속 (Inheritance)

-   **개념**: 부모 클래스(Superclass)의 속성과 행동을 자식 클래스(Subclass)가 물려받는 객체 지향의 핵심 메커니즘입니다. 클래스 간의 **"is-a" (A는 B의 한 종류다)** 관계를 표현합니다.
-   **선언**: 코틀린의 클래스는 기본적으로 `final`이므로, 상속을 허용하려면 부모 클래스와 오버라이드할 멤버에 `open` 키워드를 명시해야 합니다.

```kotlin
// 상속을 허용하기 위해 open 키워드 사용
open class Animal(val name: String) {
    // 오버라이드를 허용하기 위해 open 키워드 사용
    open fun makeSound() {
        println("Some generic sound")
    }
}

// Animal 클래스를 상속받는 Dog 클래스
class Dog(name: String) : Animal(name) {
    // 부모의 메소드를 재정의
    override fun makeSound() {
        println("Woof!")
    }
}
```

-   **장점**:
    -   **다형성(Polymorphism)**: 부모 타입으로 자식 객체를 다룰 수 있으며, 오버라이딩을 통해 각 객체의 실제 타입에 맞는 행동을 실행할 수 있습니다.
    -   **코드 재사용**: 공통된 코드와 상태를 부모 클래스에 모아 관리할 수 있습니다.
-   **단점**:
    -   **강한 결합**: 자식 클래스는 부모 클래스의 구현에 강하게 의존하게 되어, 부모 클래스의 변경이 자식에게 영향을 미칩니다.
    -   **단일 상속**: 코틀린에서는 하나의 클래스만 상속받을 수 있습니다.

## 2. 확장 (Extension)

-   **개념**: 기존 클래스의 **소스 코드를 수정하지 않고** 새로운 함수나 프로퍼티를 추가하는 코틀린 고유의 기능입니다.
-   **선언**: `fun [클래스명].[함수명]()` 형태로 선언하며, 마치 원래 있던 멤버처럼 사용할 수 있습니다.

```kotlin
// String 클래스에 새로운 함수를 '주입'
fun String.shout(): String {
    return this.uppercase() + "!!!"
}

fun main() {
    val message = "hello"
    println(message.shout()) // 출력: HELLO!!!
}
```

-   **장점**:
    -   **기존 코드 불변**: 외부 라이브러리 등 수정할 수 없는 클래스에 기능을 추가할 때 매우 유용합니다.
    -   **가독성**: 유틸리티 함수를 만드는 대신, 해당 객체에서 바로 호출할 수 있어 코드가 더 자연스럽고 읽기 쉬워집니다.
    -   **느슨한 결합**: 상속과 같은 강한 종속 관계를 만들지 않습니다.
-   **단점**:
    -   **캡슐화 한계**: 클래스의 `private` 또는 `protected` 멤버에는 접근할 수 없습니다.
    -   **다형성 미지원**: 확장은 컴파일 시점에 정적으로 결정되므로, 오버라이드할 수 없습니다.

## 3. 상속 vs 확장: 언제 무엇을 쓸까?

| 구분 | 상속 (Inheritance) | 확장 (Extension) |
| :--- | :--- | :--- |
| **관계** | **is-a** (강아지는 동물이다) | **adds-a** (String에 외치는 기능을 추가한다) |
| **결합도** | 강함 (부모-자식) | 약함 (독립적) |
| **다형성** | **지원 (오버라이드 가능)** | **미지원 (오버라이드 불가)** |
| **접근 범위** | `protected` 멤버까지 접근 가능 | `public` 멤버만 접근 가능 |
| **주 사용처** | 명확한 계층 구조와 공통 상태가 필요할 때 | 기존 클래스에 유틸리티성 기능을 추가할 때 |

> [!TIP]
> 객체 지향 설계에서는 "상속보다는 컴포지션을 사용하라(Composition over inheritance)"는 원칙이 있습니다. 코틀린에서는 이 원칙을 따라, 무분별한 상속보다는 **확장 함수**나 **위임(Delegation)**을 사용하여 기능을 조합하는 방식을 더 선호하는 경향이 있습니다.

---
> [[00. 코틀린 목차.md|⬆️ 목차로 돌아가기]]
> [[1. 인터페이스.md|⬅️ 이전: 인터페이스]] | [[5-2. 상속.md|➡️ 다음: 상속]]