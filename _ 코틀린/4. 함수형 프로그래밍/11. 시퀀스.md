# 시퀀스 (Sequence)
#Kotlin/Functional #Kotlin/Performance

> [!INFO] 시퀀스(Sequence)란?
> **시퀀스(Sequence)**는 코틀린에서 **지연 계산(Lazy Evaluation)**을 기반으로 동작하는 특별한 종류의 컬렉션입니다. 일반적인 컬렉션(`List`, `Set` 등)이 연산을 즉시 수행하는 것과 달리, 시퀀스는 최종적으로 결과가 필요한 시점까지 계산을 미룹니다.

이러한 지연 계산 방식은 여러 단계의 연산을 거치는 **대규모 데이터**를 다룰 때, 불필요한 중간 컬렉션 생성을 막아 **메모리 사용량을 최적화**하고 **성능을 향상**시키는 데 큰 장점이 있습니다.

## 1. 컬렉션 vs 시퀀스: 동작 방식의 차이

### 컬렉션 (즉시 계산, Eager Evaluation)
-   각 연산(`map`, `filter` 등)이 호출될 때마다, 전체 원소를 처리하여 **새로운 중간 컬렉션**을 생성합니다.

```kotlin
val words = listOf("a", "b", "c", "d")
val result = words
    .map { println("map: $it"); it.uppercase() } // 1. 전체 리스트를 대문자로 변환한 새 리스트 생성
    .filter { println("filter: $it"); it.length < 2 } // 2. 그 새 리스트에서 조건에 맞는 원소를 골라 또 다른 리스트 생성
    .take(1) // 3. 최종 리스트에서 첫 번째 원소를 가져옴

// 출력:
// map: a
// map: b
// map: c
// map: d
// filter: A
// filter: B
// filter: C
// filter: D
```

### 시퀀스 (지연 계산, Lazy Evaluation)
-   중간 연산들은 단지 연산 계획만 세워두고 실행을 미룹니다.
-   최종 연산(`toList`, `count` 등)이 호출될 때, 각 원소가 **하나씩** 전체 연산 파이프라인을 통과합니다. 중간 컬렉션이 생성되지 않습니다.

```kotlin
val words = listOf("a", "b", "c", "d")
val result = words.asSequence() // 시퀀스로 변환
    .map { println("map: $it"); it.uppercase() }
    .filter { println("filter: $it"); it.length < 2 }
    .take(1) // 최종 연산
    .toList() // 최종 연산

// 출력:
// map: a
// filter: A
// map: b
// filter: B
// map: c
// filter: C
// map: d
// filter: D
```
> [!NOTE]
> 위 시퀀스 예제에서 `take(1)`이 최종 연산이므로, 첫 번째 결과를 찾자마자 모든 연산이 중단됩니다. 따라서 실제 출력은 아래와 같습니다.
> ```
> map: a
> filter: A
> ```
> 이는 불필요한 계산을 하지 않는 시퀀스의 장점을 명확히 보여줍니다.

## 2. 시퀀스 생성

-   **`asSequence()`**: 기존 컬렉션을 시퀀스로 변환합니다.
    ```kotlin
    val sequence = listOf(1, 2, 3).asSequence()
    ```
-   **`sequenceOf()`**: 주어진 원소들로 시퀀스를 생성합니다.
    ```kotlin
    val sequence = sequenceOf(1, 2, 3)
    ```
-   **`generateSequence()`**: 함수를 사용하여 시퀀스를 동적으로 생성합니다. `null`을 반환하면 시퀀스가 종료됩니다. 무한 시퀀스를 만드는 데 유용합니다.
    ```kotlin
    // 1, 3, 5, 7, 9 ...
    val infiniteOddNumbers = generateSequence(1) { it + 2 }

    // take(5)를 통해 앞에서 5개만 가져옴
    println(infiniteOddNumbers.take(5).toList()) // 출력: [1, 3, 5, 7, 9]
    ```

## 3. 언제 시퀀스를 사용해야 할까?

-   **대용량 데이터**: 처리할 데이터의 양이 매우 많아 중간 컬렉션 생성이 메모리 부담을 줄 때.
-   **여러 단계의 연산**: `map`, `filter`, `flatMap` 등 여러 연산을 체이닝(chaining)할 때.
-   **무한한 데이터 스트림**: `generateSequence`를 사용하여 무한한 데이터를 다룰 때.

> [!WARNING]
> 데이터의 크기가 작거나 연산 단계가 적을 때는, 시퀀스를 생성하는 오버헤드로 인해 일반 컬렉션을 사용하는 것이 더 빠를 수 있습니다.

---
> [[00. 코틀린 목차.md|⬆️ 목차로 돌아가기]]
> [[1. 람다.md|⬅️ 이전: 람다]] | [[12. 지역 함수.md|➡️ 다음: 지역 함수]]