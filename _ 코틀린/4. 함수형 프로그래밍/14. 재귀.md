# 재귀 (Recursion)
#Kotlin/Functional

> [!INFO] 재귀란?
> **재귀(Recursion)**는 어떤 함수가 자기 자신을 다시 호출하는 프로그래밍 기법입니다. 복잡한 문제를 동일한 구조를 가진 더 작은 문제로 나누어 해결하는 데 매우 효과적이며, 특히 트리(Tree) 구조 탐색이나 분할 정복(Divide and Conquer) 알고리즘에 널리 사용됩니다.

## 1. 재귀의 구성 요소

모든 재귀 함수는 두 가지 핵심적인 부분으로 구성되어야 합니다.

1.  **기본 조건 (Base Case)**: 재귀 호출을 멈추는 조건입니다. 이 조건이 없으면 함수가 무한히 자기 자신을 호출하여 **`StackOverflowError`**가 발생합니다.
2.  **재귀 단계 (Recursive Step)**: 문제를 더 작은 단위로 쪼개고, 자기 자신을 다시 호출하는 부분입니다.

## 2. 재귀 예시: 팩토리얼

팩토리얼 `n!`은 `n * (n-1)!`로 정의될 수 있습니다. 이를 재귀 함수로 표현하면 다음과 같습니다.

```kotlin
fun factorial(n: Long): Long {
    // 기본 조건: n이 1 이하이면 1을 반환하고 재귀를 멈춤
    if (n <= 1) {
        return 1
    }
    // 재귀 단계: n과 더 작은 문제(n-1)의 결과를 곱함
    return n * factorial(n - 1)
}

println(factorial(5)) // 출력: 120
```
> **실행 과정:**
> `factorial(5)` -> `5 * factorial(4)`
> `5 * (4 * factorial(3))`
> `5 * (4 * (3 * factorial(2)))`
> `5 * (4 * (3 * (2 * factorial(1))))`
> `5 * (4 * (3 * (2 * 1)))` = 120

## 3. 꼬리 재귀 최적화 (`tailrec`)

> [!WARNING] 스택 오버플로우 (Stack Overflow)
> 일반적인 재귀 함수는 호출될 때마다 콜 스택(Call Stack)에 새로운 프레임을 쌓습니다. 재귀 깊이가 너무 깊어지면 스택이 가득 차서 `StackOverflowError`가 발생할 수 있습니다.

코틀린은 이러한 문제를 해결하기 위해 **꼬리 재귀 최적화(Tail Call Optimization)**를 지원합니다.

-   **꼬리 재귀**: 함수가 수행하는 **마지막 작업**이 자기 자신을 호출하는 것일 때를 의미합니다.
-   **`tailrec` 변경자**: 함수 앞에 `tailrec`을 붙이면, 컴파일러가 해당 함수가 꼬리 재귀 형태인지 확인하고, 맞다면 이를 **반복문(loop)** 형태로 변환하여 스택 오버플로우를 방지해 줍니다.

### 예시: 꼬리 재귀로 팩토리얼 구현

```kotlin
// 함수의 마지막 동작이 자기 자신을 호출하는 형태
tailrec fun factorial(n: Long, accumulator: Long = 1): Long {
    // 기본 조건
    if (n <= 1) {
        return accumulator
    }
    // 재귀 단계: 계산 결과를 다음 호출의 인자로 넘김
    return factorial(n - 1, n * accumulator)
}

// 스택 오버플로우 없이 매우 큰 값도 계산 가능
println(factorial(20000))
```
> `n * factorial(n-1)`은 `factorial` 호출 후 곱셈(`*`)이 마지막 작업이므로 꼬리 재귀가 아니지만, 위 예제처럼 누적 결과를 다음 함수 호출의 인자로 넘기는 방식으로 꼬리 재귀 형태로 변환할 수 있습니다.

## 4. 재귀 vs 반복문

| 구분 | 재귀 (Recursion) | 반복문 (Iteration) |
| :--- | :--- | :--- |
| **가독성** | 코드가 간결하고 직관적일 수 있음 (특히 트리 구조 등) | 로직이 복잡해지면 가독성 저하 |
| **성능** | 함수 호출 오버헤드가 있어 일반적으로 느림 | 더 빠르고 메모리 효율적 |
| **메모리** | 스택 메모리 사용 (스택 오버플로우 위험) | 스택 사용량이 일정 |

---
> [[00. 코틀린 목차.md|⬆️ 목차로 돌아가기]]
> [[13. 리스트 접기.md|⬅️ 이전: 리스트 접기]] | [[2. 람다의 중요성.md|➡️ 다음: 람다의 중요성]]