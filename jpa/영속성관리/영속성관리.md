## 엔티티 매니저 팩토리와 엔티티 매니저
* 엔티티 매니저 팩토리
	* 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다.
	* 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유 X
---
## 영속성 컨텍스트
* 영속성 컨텍스트 (persistence context)
	* 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨택스트에 저장
	* 논리적인 개념에 가깝고 눈에 보이지도 않는다
	* 엔티티 매니저를 생성할 때 하나 만들어진다
	* 엔티티 매니저를 통해서 영속성 커텍스트에 접근하며 영속성 컨텍스트를 관리
---
## 엔티티의 생명주기
⏹️ 비영속 : 영속성 커텍스트와 전혀 관계가 없는 상태
⏹️ 영속 : 영속성 컨텍스트에 저장된 상태
⏹️ 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
⏹️ 삭제 : 삭제된 상태

* 비영속
	* 엔티티 객체를 생성
	* 순수한 객체 상태이며 아직 저장되지 않는 상태
	* 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.
	* 이것을 비영속 상태라 한다.
```java
Member member = new Member();
member.setId("memeber1");
memeber.setUsername("회원1");
```
* 영속
	* 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장
	* 영속성 컨텍스트가 관리하는 엔티티를 영속 상태
	* 영속성 컨텍스트에 의해 관리된다
```java
// 객체를 저장한 상태(영속)
em.persist(member);
```
* 준영속
	* 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다
	* 특정 엔티티를 준영속 상태로 만들려면 em.detach()를 호출
	* em.close()를 호출해서 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다
```java
// 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member);
```
* 삭제
	* 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다
```java
// 객체를 삭제한 상태(삭제)
em.remove(member)
```
---
## 영속성 컨텍스트의 특징
* 영속성 컨텍스트와 식별자 값
	* 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다
	* 영속 상태는 식별자 값이 반드시 있어야한다
	* 식별자 값이 없으면 예외가 발생
* 영속성 컨텍스트와 데이터베이스 저장
	* JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시(flush)라 한다.
* 영속성 컨텍스트가 엔티티를 관리 하면 장점
	* 1차 캐시
	* 동일성 보장
	* 트랜잭션을 지원하는 쓰기 지연
	* 변경 감지
	* 지연 로딩
	* 