---
tags: [Kotlin, 객체지향, 상속]
aliases: [Kotlin Inheritance, 상속]
---

# 4. 상속

## 개요
이 문서는 코틀린의 객체 지향 프로그래밍 핵심 개념 중 하나인 상속(Inheritance)에 대해 설명합니다. 상속은 기존 클래스의 특성과 동작을 재사용하고 확장하여 새로운 클래스를 정의하는 메커니즘으로, 코드의 재사용성과 유지보수성을 높이는 데 기여합니다.

## 상속이란?
상속은 하나의 클래스(부모 클래스 또는 슈퍼 클래스)가 다른 클래스(자식 클래스 또는 서브 클래스)에게 자신의 특성(프로퍼티)과 행동(메서드)을 물려주는 객체 지향 프로그래밍의 개념입니다. 자식 클래스는 부모 클래스의 모든 공개된(public) 및 보호된(protected) 멤버를 사용할 수 있으며, 필요에 따라 이를 확장하거나 재정의(override)할 수 있습니다.

## 코틀린에서의 상속

### `open` 키워드
코틀린의 클래스와 메서드는 기본적으로 `final`입니다. 즉, 상속이나 오버라이딩이 불가능합니다. 다른 클래스가 상속받을 수 있도록 하려면 클래스 앞에 `open` 키워드를 붙여야 합니다. 마찬가지로, 자식 클래스에서 재정의할 수 있도록 하려면 메서드나 프로퍼티 앞에도 `open` 키워드를 붙여야 합니다.

```kotlin
open class Animal(val name: String) { // open 키워드를 사용하여 상속 가능하게 함
    open fun makeSound() { // open 키워드를 사용하여 오버라이딩 가능하게 함
        println("$name 이(가) 소리를 냅니다.")
    }
}

class Dog(name: String, val breed: String) : Animal(name) { // Animal 클래스 상속
    override fun makeSound() { // makeSound 메서드 오버라이딩
        println("$name 이(가 멍멍 짖습니다.")
    }

    fun fetch() {
        println("$name 이(가 공을 가져옵니다.")
    }
}

fun main() {
    val animal = Animal("동물")
    animal.makeSound() // 출력: 동물이 소리를 냅니다.

    val dog = Dog("바둑이", "진돗개")
    dog.makeSound() // 출력: 바둑이가 멍멍 짖습니다.
    dog.fetch() // 출력: 바둑이가 공을 가져옵니다.
}
```

### 생성자 호출
자식 클래스가 부모 클래스를 상속받을 때, 자식 클래스의 생성자는 부모 클래스의 생성자를 호출해야 합니다. 이는 자식 클래스 선언 시 부모 클래스 이름 뒤에 괄호를 사용하여 부모 생성자에 필요한 인자를 전달함으로써 이루어집니다.

```kotlin
open class Person(val name: String, val age: Int) {
    open fun introduce() {
        println("이름: $name, 나이: $age")
    }
}

class Student(name: String, age: Int, val studentId: String) : Person(name, age) { // 부모 생성자 호출
    override fun introduce() {
        super.introduce() // 부모 클래스의 introduce 메서드 호출
        println("학번: $studentId")
    }
}

fun main() {
    val student = Student("김철수", 20, "20231234")
    student.introduce()
}
```

## 상속의 장점과 단점

### 장점
*   **코드 재사용성**: 기존 클래스의 코드를 재사용하여 새로운 클래스를 쉽게 만들 수 있습니다.
*   **유지보수성**: 공통된 로직을 부모 클래스에 정의하고 자식 클래스에서 공유하므로, 변경이 필요할 때 한 곳만 수정하면 됩니다.
*   **확장성**: 기존 클래스를 변경하지 않고도 새로운 기능을 추가하여 확장할 수 있습니다 (개방-폐쇄 원칙).

### 단점
*   **강한 결합**: 부모 클래스와 자식 클래스 간에 강한 결합이 발생하여, 부모 클래스의 변경이 자식 클래스에 예기치 않은 영향을 줄 수 있습니다.
*   **유연성 부족**: 런타임에 부모 클래스의 구현을 변경하기 어렵습니다.
*   **계층 구조의 복잡성**: 너무 깊은 상속 계층은 코드 이해를 어렵게 만들 수 있습니다.

## 주요 내용
- 코틀린 상속의 개념 및 `open` 키워드
- 메서드 오버라이딩 및 생성자 호출 방법
- 상속의 장점과 단점
- 코드 예제를 통한 상속 이해

---
> [[00. 코틀린 목차.md|⬆️ 목차로 돌아가기]]
> [[5-1. 상속과 확장.md|⬅️ 이전: 상속과 확장]] | [[5-3. 추상 클래스.md|➡️ 다음: 추상 클래스]]
